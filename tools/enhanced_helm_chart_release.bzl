"""Enhanced Helm chart release system with optional components."""

load("//tools:helm_chart_release.bzl", "helm_chart_release_impl", "_create_chart_yaml_content")

def _create_enhanced_values_yaml_content(ctx, domain, apps, overrides, features):
    """Generate enhanced values.yaml content with optional components."""
    
    # Base structure
    values_content = """# Enhanced generated values.yaml for {domain} domain chart
# This file is automatically generated - do not edit manually

# Domain identifier
domain: {domain}

# Image configurations for each app
images:
""".format(domain = domain)

    # Add image configuration for each app
    for app_name in apps:
        registry = "ghcr.io"
        repo_name = "{}-{}".format(domain, app_name)
            
        values_content += """  {app_name}:
    name: "{registry}/whale-net/{repo_name}"
    tag: "latest"  # Will be resolved at build time
    repository: "{registry}/whale-net/{repo_name}"
""".format(app_name = app_name, registry = registry, repo_name = repo_name)

    # Add domain-specific app configuration
    values_content += """
# Domain-specific application configuration
{domain}:
  apps:
""".format(domain = domain)

    for app_name in apps:
        # Determine app type based on naming convention or configuration
        app_type = "processor" if "processor" in app_name or "worker" in app_name else "api"
        
        values_content += """    {app_name}:
      enabled: true
      type: "{app_type}"
      command: "start-{app_name}"
      version: "latest"  # Will be resolved at build time
      replicas: 1
      {port_config}
      healthPath: "/health"
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "512Mi"
          cpu: "500m"
""".format(
    app_name = app_name, 
    app_type = app_type,
    port_config = "port: 8000" if app_type == "api" else "# healthPort: 8000  # Uncomment for processor health checks"
)

        # Add optional component configurations based on features
        if features.get("pdb", False):
            values_content += """      podDisruptionBudget:
        enabled: {pdb_enabled}
        minAvailable: 1
""".format(pdb_enabled = "true" if app_type == "api" else "false")

        if features.get("hpa", False):
            values_content += """      autoscaling:
        enabled: {hpa_enabled}
        minReplicas: 1
        maxReplicas: 10
        targetCPUUtilizationPercentage: 80
""".format(hpa_enabled = "true" if app_type == "api" else "false")

        if features.get("ingress", False) and app_type == "api":
            values_content += """      ingress:
        enabled: true
        path: "/{app_name}"
        pathType: "Prefix"
""".format(app_name = app_name)

    # Add global configuration
    values_content += """
# Global configuration applied to all apps
global:
  # Default resource limits (can be overridden per app)
  resources:
    requests:
      memory: "128Mi"
      cpu: "50m"
    limits:
      memory: "256Mi"
      cpu: "200m"
  
  # Global environment variables
  env:
    LOG_LEVEL: "INFO"
    APP_ENV: "dev"
"""

    # Add optional global features
    if features.get("pdb", False):
        values_content += """
  # Global Pod Disruption Budget settings
  podDisruptionBudget:
    enabled: false  # Enabled per app as needed
    minAvailable: 1
"""

    if features.get("hpa", False):
        values_content += """
  # Global Horizontal Pod Autoscaler settings
  autoscaling:
    enabled: false  # Enabled per app as needed
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
"""

    # Add ingress configuration if enabled
    if features.get("ingress", False):
        values_content += """
# Ingress configuration
ingress:
  enabled: true
  name: ""  # Auto-generated if empty
  host: "localhost"
  ingressClassName: ""
  
  # Annotations for ingress controller
  annotations: {}
    # nginx.ingress.kubernetes.io/rewrite-target: /$2
    # nginx.ingress.kubernetes.io/use-regex: "true"
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  
  # Apps to expose (API apps are auto-detected)
  exposedApps: []
  
  # Custom paths for apps (overrides auto-generated paths)
  appPaths: {}
  
  # TLS configuration
  tls:
    enabled: false
    configs: []
"""
    else:
        values_content += """
# Ingress configuration (disabled)
ingress:
  enabled: false
"""

    # Add user overrides
    if overrides:
        values_content += "\n# User-specified overrides:\n"
        for key, value in overrides.items():
            values_content += "{}: {}\n".format(key, value)

    return values_content

def enhanced_helm_chart_release_impl(ctx):
    """Implementation for enhanced_helm_chart_release rule with optional components."""
    
    # Generate chart name using domain+name convention
    chart_name = "{}-{}".format(ctx.attr.domain, ctx.attr.name)
    
    # Create chart files
    chart_yaml = ctx.actions.declare_file("{}/Chart.yaml".format(chart_name))
    values_yaml = ctx.actions.declare_file("{}/values.yaml".format(chart_name))
    
    # Create template files in templates/ subdirectory
    deployment_yaml = ctx.actions.declare_file("{}/templates/deployment.yaml".format(chart_name))
    service_yaml = ctx.actions.declare_file("{}/templates/service.yaml".format(chart_name))
    helpers_tpl = ctx.actions.declare_file("{}/templates/_helpers.tpl".format(chart_name))
    
    # Optional component files
    optional_files = []
    if ctx.attr.features.get("pdb", False):
        pdb_yaml = ctx.actions.declare_file("{}/templates/pdb.yaml".format(chart_name))
        optional_files.append(pdb_yaml)
    
    if ctx.attr.features.get("hpa", False):
        hpa_yaml = ctx.actions.declare_file("{}/templates/hpa.yaml".format(chart_name))
        optional_files.append(hpa_yaml)
        
    if ctx.attr.features.get("ingress", False):
        ingress_yaml = ctx.actions.declare_file("{}/templates/ingress.yaml".format(chart_name))
        optional_files.append(ingress_yaml)
    
    # Generate Chart.yaml content
    chart_content = _create_chart_yaml_content(
        chart_name, 
        ctx.attr.domain, 
        ctx.attr.chart_version, 
        ctx.attr.apps,
        ctx.attr.description or ""
    )
    
    # Generate enhanced values.yaml content
    values_content = _create_enhanced_values_yaml_content(
        ctx,
        ctx.attr.domain,
        ctx.attr.apps,
        ctx.attr.values_overrides,
        ctx.attr.features
    )
    
    # Write the files
    ctx.actions.write(
        output = chart_yaml,
        content = chart_content
    )
    
    ctx.actions.write(
        output = values_yaml,
        content = values_content
    )

    # Copy enhanced template files
    for template in ctx.files.templates:
        template_path = template.short_path.split("/")[-1]  # Get just the filename
        
        # Map template files to correct names
        if template_path == "deployment-enhanced.yaml":
            target_file = deployment_yaml
        elif template_path == "service-enhanced.yaml":
            target_file = service_yaml
        elif template_path == "_helpers-enhanced.tpl":
            target_file = helpers_tpl
        elif template_path == "pdb.yaml" and ctx.attr.features.get("pdb", False):
            target_file = next((f for f in optional_files if "pdb.yaml" in f.path), None)
        elif template_path == "hpa.yaml" and ctx.attr.features.get("hpa", False):
            target_file = next((f for f in optional_files if "hpa.yaml" in f.path), None)
        elif template_path == "ingress.yaml" and ctx.attr.features.get("ingress", False):
            target_file = next((f for f in optional_files if "ingress.yaml" in f.path), None)
        else:
            continue  # Skip files not needed for this configuration
            
        if target_file:
            ctx.actions.run_shell(
                inputs = [template],
                outputs = [target_file], 
                command = "cp {} {}".format(template.path, target_file.path)
            )

    # Return all generated files
    all_files = [chart_yaml, values_yaml, deployment_yaml, service_yaml, helpers_tpl] + optional_files
    return [DefaultInfo(files = depset(all_files))]

enhanced_helm_chart_release = rule(
    implementation = enhanced_helm_chart_release_impl,
    attrs = {
        "name": attr.string(mandatory = True),
        "domain": attr.string(mandatory = True),
        "apps": attr.string_list(mandatory = True),
        "description": attr.string(default = ""),
        "chart_version": attr.string(default = "1.0.0"),
        "values_overrides": attr.string_dict(default = {}),
        "features": attr.string_dict(
            default = {},
            doc = "Optional features to enable: pdb, hpa, ingress"
        ),
        "templates": attr.label_list(
            allow_files = True,
            default = ["//tools/templates:helm_templates_enhanced"],
            doc = "Enhanced template files to include in the chart"
        ),
    },
    doc = """
    Create an enhanced Helm chart release with optional components.
    
    Features can be enabled using the features attribute:
    - "pdb": "true" - Enable Pod Disruption Budgets
    - "hpa": "true" - Enable Horizontal Pod Autoscaling  
    - "ingress": "true" - Enable Ingress resources
    
    Example:
        enhanced_helm_chart_release(
            name = "api_chart",
            domain = "myapp", 
            apps = ["api_server", "background_processor"],
            features = {
                "pdb": "true",
                "hpa": "true", 
                "ingress": "true"
            },
            description = "MyApp API services with autoscaling",
        )
    """
)

def enhanced_helm_chart_release_macro(domain, charts):
    """Convenience macro for defining multiple enhanced charts in a domain."""
    
    for chart_name, chart_config in charts.items():
        apps = chart_config["apps"]
        description = chart_config.get("description", "")
        version = chart_config.get("version", "1.0.0")
        custom_values = chart_config.get("custom_values", {})
        features = chart_config.get("features", {})
        
        # Call the enhanced rule
        enhanced_helm_chart_release(
            name = chart_name,
            domain = domain,
            apps = apps,
            description = description,
            chart_version = version,
            values_overrides = custom_values,
            features = features,
        )