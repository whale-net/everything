# Common Tilt utilities for Everything monorepo
# 
# This file provides shared functions and utilities that can be loaded
# by domain-specific Tiltfiles.
#
# Usage in a domain Tiltfile:
#   load('../../tools/tilt/common.tilt', 'bazel_build_image', 'setup_dev_util')

# Load extensions at module level (required by Starlark)
load('ext://helm_resource', 'helm_resource', 'helm_repo')

# ===========================
# Bazel Image Building
# ===========================

def build_images_from_apps(apps_dict, watch_paths, platform='linux/arm64'):
    """
    Build container images for all enabled apps using Bazel.
    
    Args:
        apps_dict: Dict of app configurations with structure:
            {
                'app-name': {
                    'enabled_env': 'ENABLE_APP_NAME',  # Optional
                    'bazel_target': '//path:target_image_load',
                    'image_name': 'domain-app-name',
                }
            }
        watch_paths: Paths to watch for changes (string or list)
        platform: Target platform (linux/arm64 or linux/amd64)
        
    Example:
        build_images_from_apps(APPS, watch_paths, platform)
    """
    print("\nüèóÔ∏è  Building images:")
    for app_name, config in apps_dict.items():
        if get_env_bool(config.get('enabled_env', ''), default='true'):
            print("  ‚úì {}".format(config['image_name']))
            bazel_build_image(
                config['image_name'],
                watch_paths,
                config['bazel_target'],
                platform=platform
            )
        else:
            print("  ‚úó {} (disabled)".format(config['image_name']))

def bazel_build_image(app_name, watch_paths, bazel_target, platform='linux/arm64'):
    """
    Build a container image using Bazel and load it into Docker.
    
    This function uses Bazel's cross-compilation support to build images
    for the correct architecture.
    
    Args:
        app_name: Name of the app for the image tag
        watch_paths: Paths to watch for changes (can be string or list)
        bazel_target: Bazel target for the image (e.g., //path/to/app:app_image_load)
        platform: Target platform (linux/arm64 or linux/amd64)
        
    Example:
        bazel_build_image(
            'my-api',
            ['./src', './libs/python'],
            '//my-domain:my_api_image_load',
            platform=detect_platform()
        )
    """
    # Map platform to Bazel platform
    platform_map = {
        'linux/arm64': '//tools:linux_arm64',
        'linux/amd64': '//tools:linux_x86_64',
    }
    bazel_platform = platform_map.get(platform, '//tools:linux_arm64')
    
    # Ensure watch_paths is a list
    if type(watch_paths) == 'string':
        watch_paths = [watch_paths]
    
    # Custom build command that uses Bazel and tags for Tilt
    # Tilt sets $EXPECTED_REF which is the full image:tag that it expects
    custom_build(
        app_name,
        'bazel run {} --platforms={} && docker tag {}:latest $EXPECTED_REF'.format(
            bazel_target, bazel_platform, app_name
        ),
        watch_paths,
        skips_local_docker=False,
        disable_push=True,
    )

def detect_platform():
    """
    Auto-detect the platform based on host architecture.
    
    Returns:
        'linux/arm64' for ARM Macs, 'linux/amd64' for Intel
    """
    arch = str(local('uname -m')).strip()
    return 'linux/arm64' if arch == 'arm64' else 'linux/amd64'

def get_bazel_platform(platform='auto'):
    """
    Get the Bazel platform string for a given platform.
    
    Args:
        platform: 'auto', 'linux/arm64', or 'linux/amd64'
        
    Returns:
        Bazel platform string (e.g., '//tools:linux_arm64')
    """
    if platform == 'auto':
        platform = detect_platform()
    
    platform_map = {
        'linux/arm64': '//tools:linux_arm64',
        'linux/amd64': '//tools:linux_x86_64',
    }
    return platform_map.get(platform, '//tools:linux_arm64')

def get_watch_paths(domain):
    """
    Get watch paths for a domain.
    
    Simple approach: Watch entire domain directory and shared libraries.
    Favors false positives (rebuilds) over false negatives (missed changes).
    
    Args:
        domain: Domain name (e.g., 'manman', 'friendly_computing_machine')
        
    Returns:
        List of paths to watch
        
    Example:
        watch_paths = get_watch_paths('manman')
        # Returns: ['./manman', './libs/python', './libs/go']
    """
    return [
        './{}'.format(domain),
        './libs/python',
        './libs/go',
    ]

# ===========================
# Infrastructure Setup
# ===========================

def setup_dev_util(namespace):
    """
    Setup the dev-util helm repository.
    
    This repository contains shared development services like postgres,
    rabbitmq, and otelcollector.
    
    Args:
        namespace: Kubernetes namespace to use
        
    Example:
        setup_dev_util('my-domain-dev')
    """
    helm_repo('dev-util', 'https://whale-net.github.io/dev-util')

def setup_postgres(namespace, db_name='default', resource_name='postgres-dev', port_forward=True):
    """
    Setup PostgreSQL using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        db_name: Database name to create
        resource_name: K8s resource name
        port_forward: Whether to forward port 5432
        
    Returns:
        Default connection URL
        
    Example:
        db_url = setup_postgres('my-domain-dev', db_name='myapp')
    """
    helm_resource(resource_name, 'dev-util/postgres-dev',
        resource_deps=['dev-util'],
        flags=[
            '--set=postgresDB={}'.format(db_name),
            '--set=namespace={}'.format(namespace)
        ]
    )
    
    if port_forward:
        k8s_resource(workload=resource_name, port_forwards='5432:5432')
    
    return 'postgresql+psycopg2://postgres:password@{}.{}.svc.cluster.local:5432/{}'.format(
        resource_name, namespace, db_name
    )

def setup_rabbitmq(namespace, resource_name='rabbitmq-dev', port_forward=True):
    """
    Setup RabbitMQ using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        resource_name: K8s resource name
        port_forward: Whether to forward ports 5672 and 15672
        
    Returns:
        Dict with connection configuration
        
    Example:
        rmq = setup_rabbitmq('my-domain-dev')
        print(rmq['host'])
    """
    
    helm_resource(resource_name, 'dev-util/rabbitmq-dev',
        resource_deps=['dev-util'],
        flags=['--set=namespace={}'.format(namespace)]
    )
    
    if port_forward:
        k8s_resource(workload=resource_name, port_forwards='5672:5672')
        k8s_resource(workload=resource_name, port_forwards='15672:15672')
    
    return {
        'host': '{}.{}.svc.cluster.local'.format(resource_name, namespace),
        'port': '5672',
        'user': 'rabbit',
        'password': 'password',
    }

def setup_otelcollector(namespace, resource_name='otelcollector-dev'):
    """
    Setup OpenTelemetry Collector using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        resource_name: K8s resource name
        
    Returns:
        OTLP endpoint URL
        
    Example:
        otlp_endpoint = setup_otelcollector('my-domain-dev')
    """
    
    helm_resource(resource_name, 'dev-util/otelcollector-dev',
        resource_deps=['dev-util'],
        flags=['--set=namespace={}'.format(namespace)]
    )
    
    return 'http://otel-collector.{}.svc.cluster.local:4317'.format(namespace)

def setup_nginx_ingress(ingress_class='nginx', http_port=30080, https_port=30443):
    """
    Setup Nginx Ingress Controller for local development.
    
    Args:
        ingress_class: Ingress class name
        http_port: NodePort for HTTP (default: 30080)
        https_port: NodePort for HTTPS (default: 30443)
        
    Example:
        setup_nginx_ingress(ingress_class='my-domain-nginx')
    """
    
    helm_repo('ingress-nginx', 'https://kubernetes.github.io/ingress-nginx')
    helm_resource('{}-ingress'.format(ingress_class), 'ingress-nginx/ingress-nginx',
        namespace='ingress-nginx',
        flags=[
            '--create-namespace',
            '--set=controller.service.type=NodePort',
            '--set=controller.hostPort.enabled=true',
            '--set=controller.service.nodePorts.http={}'.format(http_port),
            '--set=controller.service.nodePorts.https={}'.format(https_port),
            '--set=controller.admissionWebhooks.enabled=false',
            '--set=controller.ingressClassResource.name={}'.format(ingress_class),
            '--set=controller.ingressClass={}'.format(ingress_class)
        ]
    )

# ===========================
# Helm Deployment
# ===========================

def build_apps_config_with_infra(apps_dict, domain, db_url, rabbitmq_config=None, exclude_rabbitmq_for=[]):
    """
    Build apps configuration for Helm deployment with infrastructure settings.
    
    This is a helper to reduce boilerplate when building apps_config for deploy_helm_chart().
    It automatically sets up common infrastructure environment variables.
    
    Args:
        apps_dict: Dict of app configurations (same structure as APPS)
        domain: Domain name for generating helm keys
        db_url: PostgreSQL connection URL
        rabbitmq_config: Dict with rabbitmq connection info (host, port, user, password)
        exclude_rabbitmq_for: List of app names to exclude RabbitMQ config from
        
    Returns:
        Dict suitable for passing to deploy_helm_chart() as apps_config
        
    Example:
        apps_config = build_apps_config_with_infra(
            APPS,
            'manman',
            db_url,
            rabbitmq_config={'host': rmq_host, 'port': '5672', 'user': 'rabbit', 'password': 'password'},
            exclude_rabbitmq_for=['migration']
        )
        # Then customize as needed:
        apps_config['my-api']['helm_config']['ingress.tlsEnabled'] = 'false'
    """
    apps_config = {}
    
    for app_name, config in apps_dict.items():
        app_key = '{}-{}'.format(domain, app_name)
        
        # Build environment variables
        env_vars = {'POSTGRES_URL': db_url}
        
        # Add RabbitMQ config if provided and not excluded
        if rabbitmq_config and app_name not in exclude_rabbitmq_for:
            env_vars.update({
                'RABBITMQ_HOST': rabbitmq_config['host'],
                'RABBITMQ_PORT': rabbitmq_config['port'],
                'RABBITMQ_USER': rabbitmq_config['user'],
                'RABBITMQ_PASSWORD': rabbitmq_config['password'],
            })
        
        apps_config[app_name] = {
            'enabled_env': config.get('enabled_env', ''),
            'image_name': config['image_name'],
            'helm_key': app_key,
            'env': env_vars,
            'helm_config': {},
        }
    
    return apps_config

def deploy_helm_chart(domain, namespace, chart_bazel_target, chart_name, apps_config, global_config={}, use_helm_resource=False):
    """
    Deploy a Bazel-generated Helm chart with standardized configuration.
    
    This function handles the common pattern of:
    1. Building a Helm chart with Bazel
    2. Setting global configuration
    3. Configuring per-app settings (images, environment variables)
    4. Rendering and deploying the chart
    
    Args:
        domain: Domain name (e.g., 'manman', 'friendly_computing_machine')
        namespace: Kubernetes namespace
        chart_bazel_target: Bazel target for the chart (e.g., '//manman:manman_chart')
        chart_name: Name of the generated chart (e.g., 'manman-host-services')
        apps_config: Dict of app configurations with structure:
            {
                'app-name': {
                    'enabled_env': 'ENABLE_APP_NAME',  # Optional, defaults to True
                    'image_name': 'domain-app-name',
                    'env': {  # Environment variables to set
                        'VAR_NAME': 'value',
                    },
                    'helm_config': {  # Additional helm config
                        'ingress.tlsEnabled': 'false',
                    }
                }
            }
        global_config: Dict of global helm values to set
            {
                'ingressDefaults.enabled': 'true',
                'ingressDefaults.className': 'nginx',
                'someOtherGlobal': 'value',
            }
        use_helm_resource: If True, use helm_resource() instead of helm template + k8s_yaml()
                           Requires chart to be available without Bazel build
    
    Returns:
        None (deploys to k8s)
        
    Example:
        deploy_helm_chart(
            'manman',
            'manman-local-dev',
            '//manman:manman_chart',
            'manman-host-services',
            apps_config={...},
            global_config={...},
            use_helm_resource=False  # Use helm template (default)
        )
    """
    # Build the Helm chart using Bazel
    local('bazel build {}'.format(chart_bazel_target))
    
    # Extract chart path from Bazel target
    # Bazel target format: //domain:some_chart
    # Output directory format: bazel-bin/domain/helm-{chart_name}_chart/{chart_name}
    # where chart_name comes from the parameter
    domain_path = chart_bazel_target.replace('//', '').split(':')[0]
    
    chart_path = '../bazel-bin/{}/helm-{}_chart/{}'.format(
        domain_path,
        chart_name,
        chart_name
    )
    
    # Build helm values dict
    helm_values = {}
    
    # Add global configuration
    helm_values['global'] = {
        'environment': 'dev',
        'domain': domain,
        'namespace': namespace,
    }
    
    # Add user-provided global config (merge with global dict or add to root)
    for key, value in global_config.items():
        if '.' in key:
            # Nested key like 'ingressDefaults.enabled'
            parts = key.split('.')
            current = helm_values
            for part in parts[:-1]:
                if part not in current:
                    current[part] = {}
                current = current[part]
            current[parts[-1]] = value
        else:
            # Top-level key
            helm_values[key] = value
    
    # Configure each app
    helm_values['apps'] = {}
    for app_name, config in apps_config.items():
        # Check if app is enabled
        enabled_env = config.get('enabled_env')
        if enabled_env and not get_env_bool(enabled_env, default='true'):
            continue
        
        # Determine helm key (usually domain-app-name)
        app_key = config.get('helm_key', '{}-{}'.format(domain, app_name))
        image_name = config.get('image_name', app_key)
        
        # Build app config
        app_helm_config = {
            'image': image_name,
            'imageTag': 'latest',
        }
        
        # Environment variables
        env_vars = config.get('env', {})
        if env_vars:
            app_helm_config['env'] = env_vars
        
        # Additional helm configuration (merge nested dicts)
        helm_config = config.get('helm_config', {})
        for helm_key, helm_value in helm_config.items():
            if '.' in helm_key:
                # Nested key like 'ingress.tlsEnabled'
                parts = helm_key.split('.')
                current = app_helm_config
                for part in parts[:-1]:
                    if part not in current:
                        current[part] = {}
                    current = current[part]
                current[parts[-1]] = helm_value
            else:
                app_helm_config[helm_key] = helm_value
        
        helm_values['apps'][app_key] = app_helm_config
    
    print("\nüî® Deploying with Helm...")
    print("   Chart:     {}".format(chart_path))
    print("   Namespace: {}".format(namespace))
    
    if use_helm_resource:
        # Use Tilt's helm_resource (requires chart to be extractable without Bazel)
        # Convert values dict to --set arguments for now
        # TODO: Write values to temp file and use --values
        helm_set_args = []
        def flatten_dict(d, prefix=''):
            for key, value in d.items():
                full_key = '{}.{}'.format(prefix, key) if prefix else key
                if type(value) == 'dict':
                    flatten_dict(value, full_key)
                else:
                    helm_set_args.append('--set={}={}'.format(full_key, value))
        
        flatten_dict(helm_values)
        
        helm_resource(
            '{}-helm'.format(domain),
            chart_path,
            namespace=namespace,
            flags=helm_set_args,
        )
    else:
        # Use helm template + k8s_yaml (works with Bazel-built charts)
        # Convert values dict to --set arguments
        helm_set_args = []
        
        def flatten_dict(d, prefix=''):
            for key, value in d.items():
                full_key = '{}.{}'.format(prefix, key) if prefix else key
                if type(value) == 'dict':
                    flatten_dict(value, full_key)
                else:
                    helm_set_args.append('--set {}={}'.format(full_key, value))
        
        flatten_dict(helm_values)
        helm_set_string = ' '.join(helm_set_args)
        
        # Generate YAML using local() to force re-evaluation
        yaml_content = local('helm template {}-host {} --namespace {} {}'.format(
            domain,
            chart_path,
            namespace,
            helm_set_string
        ))
        
        k8s_yaml(yaml_content)

# ===========================
# Configuration Helpers
# ===========================

def get_env_bool(key, default='false'):
    """
    Get a boolean environment variable.
    
    Args:
        key: Environment variable name
        default: Default value if not set
        
    Returns:
        Boolean value
        
    Example:
        if get_env_bool('ENABLE_FEATURE'):
            print("Feature enabled")
    """
    return os.environ.get(key, default).lower() == 'true'

def get_custom_or_default(custom_env_key, custom_value_key, default_value):
    """
    Get a custom value if custom mode is enabled, otherwise use default.
    
    This pattern is useful for allowing external infrastructure in development.
    
    Args:
        custom_env_key: Environment variable to check for custom mode (e.g., 'BUILD_POSTGRES_ENV')
        custom_value_key: Environment variable with custom value (e.g., 'POSTGRES_URL')
        default_value: Default value to use
        
    Returns:
        Custom value if custom mode, otherwise default
        
    Example:
        db_url = get_custom_or_default(
            'BUILD_POSTGRES_ENV',
            'POSTGRES_URL',
            'postgresql://localhost:5432/mydb'
        )
    """
    if os.environ.get(custom_env_key, 'default') == 'custom':
        return os.environ.get(custom_value_key, default_value)
    return default_value

# ===========================
# Output Helpers
# ===========================

def print_service_info(title, services):
    """
    Print formatted service information.
    
    Args:
        title: Section title
        services: Dict of service_name -> url
        
    Example:
        print_service_info("APIs", {
            "Experience API": "http://localhost:8000/api",
            "Admin API": "http://localhost:8001/admin"
        })
    """
    print("\n" + "="*60)
    print(title)
    print("="*60)
    for name, url in services.items():
        print("  {}: {}".format(name, url))

def print_startup_banner(domain_name, namespace, platform):
    """
    Print a startup banner with configuration info.
    
    Args:
        domain_name: Name of the domain
        namespace: Kubernetes namespace
        platform: Target platform
        
    Example:
        print_startup_banner("ManMan", "manman-dev", "linux/arm64")
    """
    print("\n" + "="*60)
    print("üê≥ {} Development Environment".format(domain_name))
    print("="*60)
    print("üì¶ Namespace: {}".format(namespace))
    print("üèóÔ∏è  Platform:  {}".format(platform))
    print("="*60 + "\n")

def print_access_info(domain_name, apps_dict, ingress_port=30080, additional_services={}):
    """
    Print access information for services and infrastructure.
    
    Args:
        domain_name: Name of the domain (used for constructing hostnames)
        apps_dict: Dict of app configurations (checks enabled_env for each)
        ingress_port: Port where ingress is accessible (default: 30080)
        additional_services: Dict of additional services to display
            {
                'Service Name': 'Access info or URL',
            }
    
    Example:
        print_access_info(
            'manman',
            APPS,
            ingress_port=30080,
            additional_services={
                'PostgreSQL': 'localhost:5432 (user: postgres, pass: password)',
                'RabbitMQ Management': 'http://localhost:15672',
            }
        )
    """
    services = {}
    
    # Check for external-api apps (those that would have ingress)
    for app_name, config in apps_dict.items():
        if get_env_bool(config.get('enabled_env', ''), default='true'):
            # Construct likely hostname based on app name
            # This is a heuristic - could be made configurable
            if 'api' in app_name or 'experience' in app_name:
                app_parts = app_name.split('-')
                if app_parts[0] == 'experience':
                    hostname = 'experience'
                elif app_parts[0] == 'worker' and 'dal' in app_name:
                    hostname = 'dal'
                elif app_parts[0] == 'status':
                    hostname = 'status'
                else:
                    hostname = app_parts[0]
                
                services['{} (via curl)'.format(config['image_name'])] = \
                    'curl -H "Host: {}.{}.local" http://localhost:{}/docs'.format(
                        hostname, domain_name, ingress_port
                    )
    
    # Add additional services
    services.update(additional_services)
    
    if services:
        print_service_info("üì° Access Information", services)

def print_footer_info(domain_name, has_migrations=False):
    """
    Print footer with useful commands and tips.
    
    Args:
        domain_name: Name of the domain
        has_migrations: Whether the domain has database migrations
    
    Example:
        print_footer_info('manman', has_migrations=True)
    """
    if has_migrations:
        print("\nüìù Useful Commands:")
        print("   View logs:          tilt logs <resource-name>")
        print("   Restart resource:   tilt trigger <resource-name>")
    
    print("\nüí° Configuration Tips:")
    print("   - Use .env file for environment variables")
    print("   - Set BUILD_POSTGRES_ENV=custom for external postgres")
    print("   - Set BUILD_RABBITMQ_ENV=custom for external rabbitmq")
    print("   - Set ENABLE_<SERVICE>=false to disable services")
    print("   - Run 'tilt down' to stop all services")
    
    print("\n" + "="*60 + "\n")

