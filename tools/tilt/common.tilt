# Common Tilt utilities for Everything monorepo
# 
# This file provides shared functions and utilities that can be loaded
# by domain-specific Tiltfiles.
#
# Usage in a domain Tiltfile:
#   load('../../tools/tilt/common.tilt', 'bazel_build_image', 'setup_dev_util')

# Load extensions at module level (required by Starlark)
load('ext://helm_resource', 'helm_resource', 'helm_repo')

# ===========================
# Bazel Image Building
# ===========================

def bazel_build_image(app_name, watch_paths, bazel_target, platform='linux/arm64'):
    """
    Build a container image using Bazel and load it into Docker.
    
    This function uses Bazel's cross-compilation support to build images
    for the correct architecture.
    
    Args:
        app_name: Name of the app for the image tag
        watch_paths: Paths to watch for changes (can be string or list)
        bazel_target: Bazel target for the image (e.g., //path/to/app:app_image_load)
        platform: Target platform (linux/arm64 or linux/amd64)
        
    Example:
        bazel_build_image(
            'my-api',
            ['./src', './libs/python'],
            '//my-domain:my_api_image_load',
            platform=detect_platform()
        )
    """
    # Map platform to Bazel platform
    platform_map = {
        'linux/arm64': '//tools:linux_arm64',
        'linux/amd64': '//tools:linux_x86_64',
    }
    bazel_platform = platform_map.get(platform, '//tools:linux_arm64')
    
    # Ensure watch_paths is a list
    if type(watch_paths) == 'string':
        watch_paths = [watch_paths]
    
    # Custom build command that uses Bazel and tags for Tilt
    # Tilt sets $EXPECTED_REF which is the full image:tag that it expects
    custom_build(
        app_name,
        'bazel run {} --platforms={} && docker tag {}:latest $EXPECTED_REF'.format(
            bazel_target, bazel_platform, app_name
        ),
        watch_paths,
        skips_local_docker=False,
        disable_push=True,
    )

def detect_platform():
    """
    Auto-detect the platform based on host architecture.
    
    Returns:
        'linux/arm64' for ARM Macs, 'linux/amd64' for Intel
    """
    arch = str(local('uname -m')).strip()
    return 'linux/arm64' if arch == 'arm64' else 'linux/amd64'

def get_bazel_platform(platform='auto'):
    """
    Get the Bazel platform string for a given platform.
    
    Args:
        platform: 'auto', 'linux/arm64', or 'linux/amd64'
        
    Returns:
        Bazel platform string (e.g., '//tools:linux_arm64')
    """
    if platform == 'auto':
        platform = detect_platform()
    
    platform_map = {
        'linux/arm64': '//tools:linux_arm64',
        'linux/amd64': '//tools:linux_x86_64',
    }
    return platform_map.get(platform, '//tools:linux_arm64')

def get_watch_paths(domain):
    """
    Get watch paths for a domain.
    
    Simple approach: Watch entire domain directory and shared libraries.
    Favors false positives (rebuilds) over false negatives (missed changes).
    
    Args:
        domain: Domain name (e.g., 'manman', 'friendly_computing_machine')
        
    Returns:
        List of paths to watch
        
    Example:
        watch_paths = get_watch_paths('manman')
        # Returns: ['./manman', './libs/python', './libs/go']
    """
    return [
        './{}'.format(domain),
        './libs/python',
        './libs/go',
    ]

# ===========================
# Infrastructure Setup
# ===========================

def setup_dev_util(namespace):
    """
    Setup the dev-util helm repository.
    
    This repository contains shared development services like postgres,
    rabbitmq, and otelcollector.
    
    Args:
        namespace: Kubernetes namespace to use
        
    Example:
        setup_dev_util('my-domain-dev')
    """
    helm_repo('dev-util', 'https://whale-net.github.io/dev-util')

def setup_postgres(namespace, db_name='default', resource_name='postgres-dev', port_forward=True):
    """
    Setup PostgreSQL using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        db_name: Database name to create
        resource_name: K8s resource name
        port_forward: Whether to forward port 5432
        
    Returns:
        Default connection URL
        
    Example:
        db_url = setup_postgres('my-domain-dev', db_name='myapp')
    """
    helm_resource(resource_name, 'dev-util/postgres-dev',
        resource_deps=['dev-util'],
        flags=[
            '--set=postgresDB={}'.format(db_name),
            '--set=namespace={}'.format(namespace)
        ]
    )
    
    if port_forward:
        k8s_resource(workload=resource_name, port_forwards='5432:5432')
    
    return 'postgresql+psycopg2://postgres:password@{}.{}.svc.cluster.local:5432/{}'.format(
        resource_name, namespace, db_name
    )

def setup_rabbitmq(namespace, resource_name='rabbitmq-dev', port_forward=True):
    """
    Setup RabbitMQ using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        resource_name: K8s resource name
        port_forward: Whether to forward ports 5672 and 15672
        
    Returns:
        Dict with connection configuration
        
    Example:
        rmq = setup_rabbitmq('my-domain-dev')
        print(rmq['host'])
    """
    
    helm_resource(resource_name, 'dev-util/rabbitmq-dev',
        resource_deps=['dev-util'],
        flags=['--set=namespace={}'.format(namespace)]
    )
    
    if port_forward:
        k8s_resource(workload=resource_name, port_forwards='5672:5672')
        k8s_resource(workload=resource_name, port_forwards='15672:15672')
    
    return {
        'host': '{}.{}.svc.cluster.local'.format(resource_name, namespace),
        'port': '5672',
        'user': 'rabbit',
        'password': 'password',
    }

def setup_otelcollector(namespace, resource_name='otelcollector-dev'):
    """
    Setup OpenTelemetry Collector using dev-util helm chart.
    
    Args:
        namespace: Kubernetes namespace
        resource_name: K8s resource name
        
    Returns:
        OTLP endpoint URL
        
    Example:
        otlp_endpoint = setup_otelcollector('my-domain-dev')
    """
    
    helm_resource(resource_name, 'dev-util/otelcollector-dev',
        resource_deps=['dev-util'],
        flags=['--set=namespace={}'.format(namespace)]
    )
    
    return 'http://otel-collector.{}.svc.cluster.local:4317'.format(namespace)

def setup_nginx_ingress(ingress_class='nginx', http_port=30080, https_port=30443):
    """
    Setup Nginx Ingress Controller for local development.
    
    Args:
        ingress_class: Ingress class name
        http_port: NodePort for HTTP (default: 30080)
        https_port: NodePort for HTTPS (default: 30443)
        
    Example:
        setup_nginx_ingress(ingress_class='my-domain-nginx')
    """
    
    helm_repo('ingress-nginx', 'https://kubernetes.github.io/ingress-nginx')
    helm_resource('{}-ingress'.format(ingress_class), 'ingress-nginx/ingress-nginx',
        namespace='ingress-nginx',
        flags=[
            '--create-namespace',
            '--set=controller.service.type=NodePort',
            '--set=controller.hostPort.enabled=true',
            '--set=controller.service.nodePorts.http={}'.format(http_port),
            '--set=controller.service.nodePorts.https={}'.format(https_port),
            '--set=controller.admissionWebhooks.enabled=false',
            '--set=controller.ingressClassResource.name={}'.format(ingress_class),
            '--set=controller.ingressClass={}'.format(ingress_class)
        ]
    )

# ===========================
# Helm Deployment
# ===========================

def deploy_helm_chart(domain, namespace, chart_bazel_target, chart_name, apps_config, global_config={}):
    """
    Deploy a Bazel-generated Helm chart with standardized configuration.
    
    This function handles the common pattern of:
    1. Building a Helm chart with Bazel
    2. Setting global configuration
    3. Configuring per-app settings (images, environment variables)
    4. Rendering and deploying the chart
    
    Args:
        domain: Domain name (e.g., 'manman', 'friendly_computing_machine')
        namespace: Kubernetes namespace
        chart_bazel_target: Bazel target for the chart (e.g., '//manman:manman_chart')
        chart_name: Name of the generated chart (e.g., 'manman-host-services')
        apps_config: Dict of app configurations with structure:
            {
                'app-name': {
                    'enabled_env': 'ENABLE_APP_NAME',  # Optional, defaults to True
                    'image_name': 'domain-app-name',
                    'env': {  # Environment variables to set
                        'VAR_NAME': 'value',
                    },
                    'helm_config': {  # Additional helm config
                        'ingress.tlsEnabled': 'false',
                    }
                }
            }
        global_config: Dict of global helm values to set
            {
                'ingressDefaults.enabled': 'true',
                'ingressDefaults.className': 'nginx',
                'someOtherGlobal': 'value',
            }
    
    Returns:
        None (deploys to k8s via k8s_yaml)
        
    Example:
        deploy_helm_chart(
            'manman',
            'manman-local-dev',
            '//manman:manman_chart',
            'manman-host-services',
            apps_config={
                'experience-api': {
                    'image_name': 'manman-experience-api',
                    'env': {
                        'POSTGRES_URL': db_url,
                        'RABBITMQ_HOST': rmq_host,
                    },
                    'helm_config': {
                        'ingress.tlsEnabled': 'false',
                    }
                }
            },
            global_config={
                'ingressDefaults.enabled': 'true',
                'ingressDefaults.className': 'manman-nginx',
            }
        )
    """
    # Build the Helm chart using Bazel
    local('bazel build {}'.format(chart_bazel_target))
    
    # Extract chart path from Bazel target
    # Bazel target format: //domain:some_chart
    # Output directory format: bazel-bin/domain/helm-{chart_name}_chart/{chart_name}
    # where chart_name comes from the parameter
    domain_path = chart_bazel_target.replace('//', '').split(':')[0]
    bazel_target_name = chart_bazel_target.split(':')[-1]
    
    chart_path = '../bazel-bin/{}/helm-{}_chart/{}'.format(
        domain_path,
        chart_name,
        chart_name
    )
    
    # Build helm set arguments
    helm_set_args = []
    
    # Add global configuration
    helm_set_args.extend([
        'global.environment=dev',
        'global.domain={}'.format(domain),
        'global.namespace={}'.format(namespace),
    ])
    
    # Add user-provided global config
    for key, value in global_config.items():
        helm_set_args.append('{}={}'.format(key, value))
    
    # Configure each app
    for app_name, config in apps_config.items():
        # Check if app is enabled
        enabled_env = config.get('enabled_env')
        if enabled_env and not get_env_bool(enabled_env, default='true'):
            continue
        
        # Determine helm key (usually domain-app-name)
        app_key = config.get('helm_key', '{}-{}'.format(domain, app_name))
        image_name = config.get('image_name', app_key)
        
        # Image configuration
        helm_set_args.extend([
            'apps.{}.image={}'.format(app_key, image_name),
            'apps.{}.imageTag=latest'.format(app_key),
        ])
        
        # Environment variables
        env_vars = config.get('env', {})
        for env_key, env_value in env_vars.items():
            helm_set_args.append('apps.{}.env.{}={}'.format(app_key, env_key, env_value))
        
        # Additional helm configuration
        helm_config = config.get('helm_config', {})
        for helm_key, helm_value in helm_config.items():
            helm_set_args.append('apps.{}.{}={}'.format(app_key, helm_key, helm_value))
    
    # Build the helm set arguments as a single string
    helm_set_string = ' '.join(['--set {}'.format(arg) for arg in helm_set_args])
    
    print("\n🔨 Deploying with Helm...")
    print("   Chart:     {}".format(chart_path))
    print("   Namespace: {}".format(namespace))
    
    # Generate YAML using local() to force re-evaluation
    yaml_content = local('helm template {}-host {} --namespace {} {}'.format(
        domain,
        chart_path,
        namespace,
        helm_set_string
    ))
    
    k8s_yaml(yaml_content)

# ===========================
# Configuration Helpers
# ===========================

def get_env_bool(key, default='false'):
    """
    Get a boolean environment variable.
    
    Args:
        key: Environment variable name
        default: Default value if not set
        
    Returns:
        Boolean value
        
    Example:
        if get_env_bool('ENABLE_FEATURE'):
            print("Feature enabled")
    """
    return os.environ.get(key, default).lower() == 'true'

def get_custom_or_default(custom_env_key, custom_value_key, default_value):
    """
    Get a custom value if custom mode is enabled, otherwise use default.
    
    This pattern is useful for allowing external infrastructure in development.
    
    Args:
        custom_env_key: Environment variable to check for custom mode (e.g., 'BUILD_POSTGRES_ENV')
        custom_value_key: Environment variable with custom value (e.g., 'POSTGRES_URL')
        default_value: Default value to use
        
    Returns:
        Custom value if custom mode, otherwise default
        
    Example:
        db_url = get_custom_or_default(
            'BUILD_POSTGRES_ENV',
            'POSTGRES_URL',
            'postgresql://localhost:5432/mydb'
        )
    """
    if os.environ.get(custom_env_key, 'default') == 'custom':
        return os.environ.get(custom_value_key, default_value)
    return default_value

# ===========================
# Output Helpers
# ===========================

def print_service_info(title, services):
    """
    Print formatted service information.
    
    Args:
        title: Section title
        services: Dict of service_name -> url
        
    Example:
        print_service_info("APIs", {
            "Experience API": "http://localhost:8000/api",
            "Admin API": "http://localhost:8001/admin"
        })
    """
    print("\n" + "="*60)
    print(title)
    print("="*60)
    for name, url in services.items():
        print("  {}: {}".format(name, url))

def print_startup_banner(domain_name, namespace, platform):
    """
    Print a startup banner with configuration info.
    
    Args:
        domain_name: Name of the domain
        namespace: Kubernetes namespace
        platform: Target platform
        
    Example:
        print_startup_banner("ManMan", "manman-dev", "linux/arm64")
    """
    print("\n" + "="*60)
    print("🐳 {} Development Environment".format(domain_name))
    print("="*60)
    print("📦 Namespace: {}".format(namespace))
    print("🏗️  Platform:  {}".format(platform))
    print("="*60 + "\n")
