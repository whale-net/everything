#!/usr/bin/env python3
"""Generate Bazel BUILD rules for per-package OCI layers.

This script is invoked as a Bazel genrule to dynamically discover
pip packages from a py_binary's runfiles and generate pkg_tar rules
for each package.

Output: A BUILD.bazel fragment with one pkg_tar rule per package.
"""

import json
import sys
from pathlib import Path


def discover_packages_from_runfiles(runfiles_manifest: str) -> list[str]:
    """Extract pip package names from runfiles manifest.
    
    Args:
        runfiles_manifest: Path to .runfiles_manifest file
        
    Returns:
        Sorted list of unique package names (e.g., ['fastapi', 'pydantic'])
    """
    manifest_path = Path(runfiles_manifest)
    if not manifest_path.exists():
        return []
    
    packages = set()
    with open(manifest_path) as f:
        for line in f:
            # Format: runfile_path actual_path
            parts = line.strip().split(maxsplit=1)
            if len(parts) != 2:
                continue
            
            runfile_path = parts[0]
            
            # Look for pip packages: rules_pycross++lock_repos+pypi/_lock/package@version/...
            if "rules_pycross++lock_repos+pypi/_lock/" in runfile_path:
                path_parts = runfile_path.split("/")
                try:
                    lock_idx = path_parts.index("_lock")
                    if lock_idx + 1 < len(path_parts):
                        package_with_version = path_parts[lock_idx + 1]
                        # Extract package name (before @)
                        package_name = package_with_version.split("@")[0]
                        packages.add(package_name)
                except ValueError:
                    continue
    
    return sorted(packages)


def generate_build_rules(binary_target: str, packages: list[str], output_file: str):
    """Generate BUILD.bazel rules for per-package layering.
    
    Args:
        binary_target: The py_binary target (e.g., "//demo/hello_fastapi:hello_fastapi")
        packages: List of pip package names
        output_file: Where to write the generated BUILD rules
    """
    lines = [
        '"""Auto-generated per-package layer rules.',
        '',
        'Generated by tools/generate_package_layers.py',
        'DO NOT EDIT MANUALLY',
        '"""',
        '',
        'load("@rules_pkg//:pkg.bzl", "pkg_tar")',
        '',
    ]
    
    # Generate a pkg_tar for each package
    # Note: This is a simplified version - filtering specific packages from runfiles
    # is complex in Bazel. We'll create separate tars but they'll overlap.
    # A proper implementation would need custom Bazel rules.
    
    for package in packages:
        pkg_var = package.replace("-", "_")
        lines.extend([
            f'# Layer for {package}',
            f'pkg_tar(',
            f'    name = "layer_{pkg_var}",',
            f'    srcs = ["{binary_target}"],',
            f'    package_dir = "/app",',
            f'    include_runfiles = True,',
            f'    strip_prefix = ".",',
            f'    # TODO: Filter to only {package} files',
            f'    # This is non-trivial in Bazel without custom rules',
            f'    visibility = ["//visibility:public"],',
            f')',
            '',
        ])
    
    # Generate a list target for easy reference
    lines.extend([
        '# List of all package layer targets',
        'PACKAGE_LAYERS = [',
    ])
    for package in packages:
        pkg_var = package.replace("-", "_")
        lines.append(f'    ":layer_{pkg_var}",')
    lines.extend([
        ']',
        '',
    ])
    
    with open(output_file, 'w') as f:
        f.write('\n'.join(lines))
    
    print(f"Generated {len(packages)} package layer rules in {output_file}")


def main():
    if len(sys.argv) != 4:
        print("Usage: generate_package_layers.py <binary_target> <runfiles_manifest> <output_file>")
        sys.exit(1)
    
    binary_target = sys.argv[1]
    runfiles_manifest = sys.argv[2]
    output_file = sys.argv[3]
    
    print(f"Discovering packages from: {runfiles_manifest}")
    packages = discover_packages_from_runfiles(runfiles_manifest)
    print(f"Found {len(packages)} packages: {', '.join(packages[:5])}...")
    
    generate_build_rules(binary_target, packages, output_file)


if __name__ == "__main__":
    main()
