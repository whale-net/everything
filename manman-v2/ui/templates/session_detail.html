{{define "session_detail_content"}}
<div class="action-bar">
    <h1>Session {{.Session.SessionId}}</h1>
    <div>
        <a href="/sessions" class="btn btn-secondary btn-sm">Back to Sessions</a>
        {{if eq .Session.Status "running"}}
        <form hx-post="/sessions/{{.Session.SessionId}}/stop" hx-target="body" style="display: inline;">
            <button type="submit" class="btn btn-danger btn-sm">Stop Session</button>
        </form>
        {{end}}
    </div>
</div>

<div class="card">
    <div class="card-header">
        <div class="card-title">Session Details</div>
    </div>
    <dl style="display: grid; grid-template-columns: 200px 1fr; gap: 0.5rem;">
        <dt><strong>Session ID:</strong></dt>
        <dd>{{.Session.SessionId}}</dd>

        <dt><strong>Status:</strong></dt>
        <dd><span class="badge {{statusBadge .Session.Status}}">{{.Session.Status}}</span></dd>

        <dt><strong>Available:</strong></dt>
        <dd>
            {{if eq .Session.Status "running"}}
            <span class="badge badge-success">Yes (Ready for connections)</span>
            {{else if or (eq .Session.Status "starting") (eq .Session.Status "pending")}}
            <span class="badge badge-warning">Starting (Wait for it to be ready)</span>
            {{else}}
            <span class="badge badge-danger">No (Server is not running)</span>
            {{end}}
        </dd>

        <dt><strong>Server Game Config ID:</strong></dt>
        <dd>{{.Session.ServerGameConfigId}}</dd>

        <dt><strong>Started:</strong></dt>
        <dd>{{timeAgo .Session.StartedAt}} ({{formatTime .Session.StartedAt}})</dd>

        <dt><strong>Ended:</strong></dt>
        <dd>{{timeAgo .Session.EndedAt}} ({{formatTime .Session.EndedAt}})</dd>

        <dt><strong>Exit Code:</strong></dt>
        <dd>{{.Session.ExitCode}}</dd>
    </dl>
</div>

{{if eq .Session.Status "running"}}
<div class="card">
    <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
        <div class="card-title">Live Logs</div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="toggle-logs" class="btn btn-sm btn-secondary">Hide</button>
            <button id="clear-logs" class="btn btn-sm btn-secondary">Clear</button>
            <span id="log-status" style="font-size: 0.85rem; color: #888;">Connecting...</span>
        </div>
    </div>
    <div id="log-viewer" class="log-viewer">
        <pre id="log-output" class="log-output"></pre>
    </div>
</div>

<style>
.log-viewer {
    background: #1e1e1e;
    border-radius: 4px;
    max-height: 600px;
    overflow: hidden;
    display: block;
}
.log-output {
    margin: 0;
    padding: 1rem;
    color: #d4d4d4;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.875rem;
    overflow-y: auto;
    max-height: 600px;
    white-space: pre-wrap;
    word-wrap: break-word;
}
.log-line {
    display: block;
}
.log-stdout {
    color: #d4d4d4;
}
.log-stderr {
    color: #f48771;
}
.log-host {
    color: #4fc1ff;
}
.log-viewer.collapsed .log-output {
    display: none;
}
</style>

<script>
(function() {
    const logOutput = document.getElementById('log-output');
    const logStatus = document.getElementById('log-status');
    const logViewer = document.getElementById('log-viewer');
    const toggleBtn = document.getElementById('toggle-logs');
    const clearBtn = document.getElementById('clear-logs');

    let autoScroll = true;
    let evtSource = null;

    function connect() {
        evtSource = new EventSource('/sessions/{{.Session.SessionId}}/logs/stream');

        evtSource.onopen = () => {
            logStatus.textContent = '● Connected';
            logStatus.style.color = '#4fc1ff';
        };

        evtSource.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'connected') return;

            // Format timestamp
            const date = new Date(data.timestamp);
            const time = date.toLocaleTimeString('en-US', { hour12: false });

            // Create log line with color coding
            const line = document.createElement('span');
            line.className = `log-line log-${data.source}`;
            line.textContent = `[${time}] [${data.source}] ${data.message}\n`;
            logOutput.appendChild(line);

            // Auto-scroll to bottom if enabled
            if (autoScroll) {
                logOutput.scrollTop = logOutput.scrollHeight;
            }

            // Limit to last 1000 lines (prevent memory bloat)
            const lines = logOutput.children;
            if (lines.length > 1000) {
                logOutput.removeChild(lines[0]);
            }
        };

        evtSource.onerror = () => {
            logStatus.textContent = '● Disconnected';
            logStatus.style.color = '#f48771';
            evtSource.close();
            setTimeout(connect, 2000);  // Auto-reconnect after 2s
        };
    }

    toggleBtn.onclick = () => {
        logViewer.classList.toggle('collapsed');
        toggleBtn.textContent = logViewer.classList.contains('collapsed') ? 'Show' : 'Hide';
    };

    clearBtn.onclick = () => {
        logOutput.textContent = '';
    };

    // Detect manual scroll (disable auto-scroll)
    logOutput.onscroll = () => {
        const atBottom = logOutput.scrollHeight - logOutput.clientHeight <= logOutput.scrollTop + 50;
        autoScroll = atBottom;
    };

    // Start streaming
    connect();

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (evtSource) evtSource.close();
    });
})();
</script>
{{else}}
<div class="card">
    <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
        <div class="card-title">Historical Logs</div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="load-historical" class="btn btn-sm btn-primary">Load Logs</button>
            <button id="download-historical" class="btn btn-sm btn-secondary" style="display: none;">Download</button>
            <button id="clear-historical" class="btn btn-sm btn-secondary">Clear</button>
        </div>
    </div>
    <div style="padding: 1rem;">
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
            <div>
                <label for="start-time" style="display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500;">Start Time:</label>
                <input type="datetime-local" id="start-time" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.875rem;">
            </div>
            <div>
                <label for="end-time" style="display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500;">End Time:</label>
                <input type="datetime-local" id="end-time" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.875rem;">
            </div>
        </div>
        <div id="historical-status" style="font-size: 0.875rem; color: #888; margin-bottom: 1rem;"></div>
    </div>
    <div id="historical-log-viewer" class="log-viewer" style="display: none;">
        <pre id="historical-log-output" class="log-output"></pre>
    </div>
</div>

<script>
(function() {
    const loadBtn = document.getElementById('load-historical');
    const downloadBtn = document.getElementById('download-historical');
    const clearBtn = document.getElementById('clear-historical');
    const startTimeInput = document.getElementById('start-time');
    const endTimeInput = document.getElementById('end-time');
    const statusDiv = document.getElementById('historical-status');
    const logViewer = document.getElementById('historical-log-viewer');
    const logOutput = document.getElementById('historical-log-output');

    let currentLogData = null; // Store current log data for download

    // Set default time range (last 5 minutes before session end)
    {{if .Session.EndedAt}}
    const endTime = new Date({{.Session.EndedAt}} * 1000);
    const startTime = new Date(endTime.getTime() - (5 * 60 * 1000));  // 5 minutes before
    startTimeInput.value = startTime.toISOString().slice(0, 16);
    endTimeInput.value = endTime.toISOString().slice(0, 16);
    {{end}}

    loadBtn.onclick = async () => {
        const start = new Date(startTimeInput.value);
        const end = new Date(endTimeInput.value);

        if (!start || !end) {
            statusDiv.textContent = 'Please select both start and end times';
            statusDiv.style.color = '#f48771';
            return;
        }

        // Validate 30-minute limit
        const diffMinutes = (end - start) / (1000 * 60);
        if (diffMinutes > 30) {
            statusDiv.textContent = 'Time range too large (max 30 minutes)';
            statusDiv.style.color = '#f48771';
            return;
        }

        statusDiv.textContent = 'Loading logs...';
        statusDiv.style.color = '#4fc1ff';
        loadBtn.disabled = true;

        try {
            const url = `/api/sessions/historical-logs?session_id={{.Session.SessionId}}&start=${Math.floor(start.getTime() / 1000)}&end=${Math.floor(end.getTime() / 1000)}`;
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }

            const data = await response.json();
            logOutput.textContent = '';

            if (!data.batches || data.batches.length === 0) {
                statusDiv.textContent = 'No logs found for this time range';
                statusDiv.style.color = '#888';
                logViewer.style.display = 'none';
                downloadBtn.style.display = 'none';
                currentLogData = null;
                return;
            }

            // Store data for download
            currentLogData = data;

            // Display batches in order
            for (const batch of data.batches) {
                const lines = batch.content.split('\n');
                for (const lineText of lines) {
                    if (!lineText.trim()) continue;

                    // Parse log format: [timestamp] [source] message
                    const match = lineText.match(/\[([^\]]+)\] \[([^\]]+)\] (.+)/);
                    if (match) {
                        const [, timestamp, source, message] = match;
                        const line = document.createElement('span');
                        line.className = `log-line log-${source}`;
                        line.textContent = `[${timestamp}] [${source}] ${message}\n`;
                        logOutput.appendChild(line);
                    } else {
                        // Fallback for lines that don't match format
                        const line = document.createElement('span');
                        line.className = 'log-line';
                        line.textContent = lineText + '\n';
                        logOutput.appendChild(line);
                    }
                }
            }

            logViewer.style.display = 'block';
            downloadBtn.style.display = 'inline-block';
            statusDiv.textContent = `Loaded ${data.batches.length} log batch(es)`;
            statusDiv.style.color = '#4fc1ff';
        } catch (err) {
            statusDiv.textContent = `Error: ${err.message}`;
            statusDiv.style.color = '#f48771';
        } finally {
            loadBtn.disabled = false;
        }
    };

    downloadBtn.onclick = () => {
        if (!currentLogData || !currentLogData.batches) {
            return;
        }

        // Combine all batches into a single text file
        let combinedLogs = '';
        for (const batch of currentLogData.batches) {
            combinedLogs += batch.content;
        }

        // Create download link
        const blob = new Blob([combinedLogs], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // Generate filename with timestamp range
        const startDate = new Date(startTimeInput.value);
        const endDate = new Date(endTimeInput.value);
        const filename = `session-{{.Session.SessionId}}-logs-${startDate.toISOString().replace(/[:.]/g, '-')}_${endDate.toISOString().replace(/[:.]/g, '-')}.log`;
        a.download = filename;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    clearBtn.onclick = () => {
        logOutput.textContent = '';
        logViewer.style.display = 'none';
        downloadBtn.style.display = 'none';
        statusDiv.textContent = '';
        currentLogData = null;
    };

    // Auto-load logs on page load
    {{if .Session.EndedAt}}
    setTimeout(() => loadBtn.click(), 500);
    {{end}}
})();
</script>
{{end}}

<div class="card">
    <div class="card-header">
        <div class="card-title">Parameters</div>
    </div>
    <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-left: 4px solid #3498db;">
        <strong>Parameter resolution:</strong> Session parameters override Server Game Config, which overrides GameConfig defaults.
    </div>
    {{if .Session.Parameters}}
    <table>
        <thead>
            <tr>
                <th>Key</th>
                <th>Value</th>
            </tr>
        </thead>
        <tbody>
            {{range $key, $value := .Session.Parameters}}
            <tr>
                <td><code>{{$key}}</code></td>
                <td><code>{{$value}}</code></td>
            </tr>
            {{end}}
        </tbody>
    </table>
    {{else}}
    <div class="empty-state">
        <p>No session parameters.</p>
    </div>
    {{end}}
</div>
{{end}}
