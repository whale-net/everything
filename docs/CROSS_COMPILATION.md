# Cross-Compilation for Python Applications

## Overview

This repository implements **true cross-compilation** for Python applications using **Bazel platform transitions**. This allows building ARM64 container images on x86_64 machines with correct architecture-specific compiled dependencies (e.g., pydantic, numpy, pandas, pillow, cryptography).

## The Problem We Solved

### Before Platform Transitions

Without platform transitions, both AMD64 and ARM64 container images would get compiled wheels for the **build host's architecture**:

```bash
# Building on x86_64 host
bazel build //demo/hello_fastapi:hello_fastapi_image_arm64
docker run hello_fastapi_linux_amd64_arm64:latest -c 'find /app -name "*pydantic_core*.so"'
# Result: _pydantic_core.cpython-311-x86_64-linux-gnu.so  ❌ WRONG!
# This would crash at runtime on ARM64 with "cannot execute binary file: Exec format error"
```

**Root Cause**: Pycross selects wheels based on Bazel's target platform configuration. Both `*_linux_amd64` and `*_linux_arm64` binaries were being built with the same platform configuration (the host platform), so pycross selected the same wheels for both.

### After Platform Transitions

With platform transitions, each binary variant is built with its **target platform** configuration:

```bash
# Building on x86_64 host
bazel build //demo/hello_fastapi:hello_fastapi_image_arm64
docker run hello_fastapi_linux_amd64_arm64:latest -c 'find /app -name "*pydantic_core*.so"'
# Result: _pydantic_core.cpython-311-aarch64-linux-gnu.so  ✅ CORRECT!
```

## How It Works

### 1. Platform Transitions in `multiplatform_py_binary`

The `multiplatform_py_binary` macro creates platform-specific binaries using Bazel transitions:

```python
# tools/python_binary.bzl
def _platform_transition_impl(settings, attr):
    """Transition to the target platform for the binary variant."""
    return {"//command_line_option:platforms": str(attr.target_platform)}

_platform_transition = transition(
    implementation = _platform_transition_impl,
    inputs = [],
    outputs = ["//command_line_option:platforms"],
)
```

When you use `multiplatform_py_binary`:
- `*_linux_amd64` is built with `--platforms=//tools:linux_x86_64`
- `*_linux_arm64` is built with `--platforms=//tools:linux_arm64`

### 2. Pycross Config Settings

Pycross creates `config_setting` targets for each platform environment:

```python
# Generated by pycross in @rules_pycross++environments+everything_pycross_envs
config_setting(
  name = "python_3.11_x86_64-unknown-linux-gnu_config",
  flag_values = {"@everything_pycross_envs//:_interpreter_version": "3.11.13"},
  constraint_values = ["@platforms//os:linux", "@platforms//cpu:x86_64"],
)

config_setting(
  name = "python_3.11_aarch64-unknown-linux-gnu_config",
  flag_values = {"@everything_pycross_envs//:_interpreter_version": "3.11.13"},
  constraint_values = ["@platforms//os:linux", "@platforms//cpu:aarch64"],
)
```

### 3. Wheel Selection with `select()`

Pycross generates `select()` statements that choose wheels based on the active config_setting:

```python
# Generated in @pypi//_lock/lock.bzl
native.alias(
    name = "_wheel_pydantic-core@2.33.2",
    actual = select({
        ":_env_python_3.11_x86_64-unknown-linux-gnu": 
            "@pypi_pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_x86_64...",
        ":_env_python_3.11_aarch64-unknown-linux-gnu": 
            "@pypi_pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_aarch64...",
        # ...
    }),
)
```

When the platform transition changes `--platforms`, the matching config_setting activates, and pycross selects the correct wheel.

### 4. Container Image Builder

The `multiplatform_image` function accepts platform-specific binaries:

```python
# tools/container_image.bzl
def multiplatform_image(
    name,
    binary = None,
    binary_amd64 = None,
    binary_arm64 = None,
    ...):
    """Build multiplatform OCI images with optional platform-specific binaries."""
    
    amd64_binary = binary_amd64 if binary_amd64 else binary
    arm64_binary = binary_arm64 if binary_arm64 else binary
    
    container_image(name = name + "_amd64", binary = amd64_binary, ...)
    container_image(name = name + "_arm64", binary = arm64_binary, ...)
```

### 5. Release System Integration

The `release_app` macro automatically detects Python apps and passes platform-specific binaries:

```python
# tools/release.bzl
if language == "python":
    multiplatform_image(
        name = image_target,
        binary_amd64 = ":" + name + "_linux_amd64",
        binary_arm64 = ":" + name + "_linux_arm64",
        ...
    )
else:  # Go apps
    multiplatform_image(
        name = image_target,
        binary = binary_target,  # Same binary for all platforms
        ...
    )
```

## Usage

### Creating a Python App with Cross-Compilation

```python
# demo/my_app/BUILD.bazel
load("//tools:python_binary.bzl", "multiplatform_py_binary")
load("//tools:release.bzl", "release_app")

py_library(
    name = "my_app_lib",
    srcs = ["main.py"],
    deps = [
        "@pypi//pydantic",  # Compiled dependency
        "@pypi//numpy",     # Compiled dependency
    ],
)

multiplatform_py_binary(
    name = "my_app",
    srcs = ["main.py"],
    deps = [":my_app_lib"],
)

release_app(
    name = "my_app",
    language = "python",
    domain = "api",
)
```

This automatically creates:
- `my_app_linux_amd64` - x86_64 binary with x86_64 wheels
- `my_app_linux_arm64` - aarch64 binary with aarch64 wheels
- `my_app_image_amd64` - AMD64 container image
- `my_app_image_arm64` - ARM64 container image
- `my_app_image` - Multi-platform manifest list

### Building Images

```bash
# Build AMD64 image
bazel run //demo/my_app:my_app_image_load

# Build ARM64 image
bazel run //demo/my_app:my_app_image_arm64_load

# Build both + manifest
bazel build //demo/my_app:my_app_image
```

### Verification

Always verify cross-compilation works by checking the `.so` files:

```bash
# Check AMD64 container
docker run --rm --entrypoint /bin/sh my_app_linux_amd64:latest \
  -c 'find /app -name "*pydantic_core*.so" | xargs ls -la'
# Should show: x86_64-linux-gnu.so

# Check ARM64 container  
docker run --rm --entrypoint /bin/sh my_app_linux_amd64_arm64:latest \
  -c 'find /app -name "*pydantic_core*.so" | xargs ls -la'
# Should show: aarch64-linux-gnu.so
```

## Testing

### Automated Cross-Compilation Test

We have a **critical test** that verifies cross-compilation continues working:

```bash
# Load the test images first (prerequisite)
bazel run //demo/hello_fastapi:hello_fastapi_image_amd64_load
bazel run //demo/hello_fastapi:hello_fastapi_image_arm64_load

# Run the test through Bazel (recommended)
bazel test //tools:test_cross_compilation --test_output=streamed

# Test is marked as "manual" so it doesn't run with //...
# This is because it requires Docker and pre-loaded images
```

The test (`tools/test_cross_compilation.sh`):
1. Checks that both AMD64 and ARM64 images are loaded in Docker
2. Inspects each container to verify correct architecture-specific `.so` files
3. Verifies AMD64 containers have x86_64 wheels
4. Verifies ARM64 containers have aarch64 wheels
5. **Fails loudly** if cross-compilation is broken

**Why it's manual**: The test cannot run in Bazel's sandbox because it:
- Requires pre-loaded Docker images
- Requires Docker daemon access
- Tests actual container artifacts, not just build outputs

### CI Integration

The test runs automatically in GitHub Actions CI on every PR and push. CI loads the images before running the test:

```yaml
# .github/workflows/ci.yml
- name: Verify Cross-Compilation (Critical)
  run: |
    bazel test //tools:test_cross_compilation --config=ci --test_output=streamed
```

If this test fails, **DO NOT MERGE** - it means ARM64 containers will crash at runtime.

## Troubleshooting

### ARM64 Container Has x86_64 Wheels

**Symptom**: ARM64 container shows `x86_64-linux-gnu.so` instead of `aarch64-linux-gnu.so`

**Diagnosis**:
```bash
# Check what wheels are being selected
bazel cquery 'deps(//demo/my_app:my_app_linux_arm64)' | grep pydantic_core
# Should show aarch64 wheel, if showing x86_64 then transitions aren't working
```

**Fix**: Verify platform transitions are configured:
1. Check `multiplatform_py_binary` has `_platform_transition` rule
2. Verify `release_app` passes `binary_amd64` and `binary_arm64` correctly
3. Ensure `multiplatform_image` uses platform-specific binaries

### Both Binaries Get Same Wheels

**Symptom**: `bazel cquery` shows both AMD64 and ARM64 binaries get the same wheels

**Cause**: Platform transition not being applied

**Fix**: Check the `_multiplatform_py_binary_rule`:
```python
_multiplatform_py_binary_rule = rule(
    attrs = {
        "binary": attr.label(
            cfg = _platform_transition,  # ← Must be here
            executable = True,
            mandatory = True,
        ),
        "target_platform": attr.label(mandatory = True),
        "_allowlist_function_transition": attr.label(
            default = "@bazel_tools//tools/allowlists/function_transition_allowlist",
        ),
    },
    executable = True,
)
```

### Container Build Uses Wrong Binary

**Symptom**: ARM64 image has the correct runfiles path but wrong architecture

**Cause**: `container_image.bzl` not using platform-specific binaries

**Fix**: Verify `multiplatform_image` passes correct binaries to `container_image`:
```python
# Should use binary_amd64 and binary_arm64, not just binary
container_image(name = name + "_amd64", binary = amd64_binary, ...)
container_image(name = name + "_arm64", binary = arm64_binary, ...)
```

## Performance Notes

- **First build**: Longer due to building for multiple platforms (~2x build time)
- **Incremental builds**: Bazel caches each platform separately (fast)
- **CI builds**: Platform transitions work correctly with Bazel remote cache
- **No emulation needed**: This is true cross-compilation, not QEMU emulation

## Limitations

- **Go apps**: Don't need platform transitions (Go cross-compiles natively)
- **Pure Python**: Works without transitions (no compiled deps to worry about)
- **Build host**: Must have internet access to download both AMD64 and ARM64 wheels

## Future Improvements

- Add support for more platforms (macOS ARM64, Windows, etc.)
- Optimize build caching for platform transitions
- Add platform-specific tests that run in CI
- Support custom Python toolchains per platform

## References

- [Bazel Platforms Documentation](https://bazel.build/concepts/platforms)
- [Bazel Transitions](https://bazel.build/rules/lib/transition)
- [Pycross Configuration](https://github.com/jvolkman/rules_pycross)
- [Python Wheel Tags](https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/)
