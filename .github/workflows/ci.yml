name: CI

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  # Build job - builds all targets to verify compilation
  build:
    name: Build
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'build'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Build all targets
      run: |
        # Build all targets to verify compilation
        bazel build //...
        # Shutdown Bazel server to prevent hanging
        bazel shutdown

  # Test job - builds and tests in one step for better cache utilization
  # Note: Docker setup not needed here - all unit tests use mocking
  # Integration tests requiring Docker run in separate test-container-arch job
  test:
    name: Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'test'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Run tests
      run: |
        # Run all tests and let Bazel handle caching
        bazel test //...
        # Shutdown Bazel server to prevent hanging
        bazel shutdown
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: bazel-testlogs/
        retention-days: 7

  # Container architecture test - verify cross-compilation works correctly
  # Runs in parallel with test job for faster CI
  test-container-arch:
    name: Test Container Architecture
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'container-arch'
        setup-docker: 'true'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Verify Cross-Compilation (Critical)
      run: |
        # CRITICAL TEST: Verify cross-platform builds work correctly
        # This ensures ARM64 containers get aarch64 wheels (not x86_64)
        # Uses oci_image_index with platform transitions for true multiarch images
        # If this fails, ARM64 deployments will crash at runtime!
        echo "::group::Cross-Compilation Verification"
        bazel test //tools/scripts:test_cross_compilation --config=ci --test_output=streamed
        echo "::endgroup::"
        # Shutdown Bazel server to prevent hanging
        bazel shutdown

  # Plan Docker builds - determine which apps need building
  plan-docker:
    name: Plan Docker Builds
    runs-on: ubuntu-latest
    needs: [build, test, test-container-arch]
    outputs:
      matrix: ${{ steps.plan.outputs.matrix }}
      apps: ${{ steps.plan.outputs.apps }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'plan'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Plan Docker builds using release tool
      id: plan
      env:
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      run: |
        # Determine what to build based on changes
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # For PRs, compare against the base branch
          BASE_COMMIT="${{ github.event.pull_request.base.sha }}"
          echo "PR detected: comparing against base commit $BASE_COMMIT"
          EVENT_TYPE="pull_request"
        elif [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ]; then
          # For pushes, compare against the previous commit
          BASE_COMMIT="${{ github.event.before }}"
          echo "Push detected: comparing against previous commit $BASE_COMMIT"
          EVENT_TYPE="push"
        else
          # Fallback: build all apps
          echo "Cannot determine base commit, building all apps"
          BASE_COMMIT=""
          EVENT_TYPE="fallback"
        fi
        
        # Use release helper to plan the Docker builds
        echo "Planning Docker builds using release tool..."
        PLAN_OUTPUT=$(bazel run //tools:release -- plan \
          --event-type "$EVENT_TYPE" \
          --base-commit="$BASE_COMMIT" \
          --format github)
        
        # Parse output from release helper and set GitHub outputs
        # Use process substitution to avoid subshell issues with pipes
        while IFS= read -r line; do
          if [[ "$line" == matrix=* ]]; then
            echo "${line}" >> $GITHUB_OUTPUT
          elif [[ "$line" == apps=* ]]; then
            echo "${line}" >> $GITHUB_OUTPUT
            APPS_LIST="${line#apps=}"
            if [[ -n "$APPS_LIST" ]]; then
              echo "Apps to build: $APPS_LIST"
            else
              echo "No apps to build"
            fi
          fi
        done <<< "$PLAN_OUTPUT"
        
        # Shutdown Bazel server to prevent hanging
        bazel shutdown

  # Docker job - builds container images using the release tool (main branch only)
  docker:
    name: Build ${{ matrix.domain }}-${{ matrix.app }} Image
    runs-on: ubuntu-latest
    needs: plan-docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.plan-docker.outputs.apps && needs.plan-docker.outputs.apps != 'null'
    strategy:
      matrix: ${{ fromJson(needs.plan-docker.outputs.matrix) }}
      fail-fast: false
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        setup-docker: 'true'
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
      
    # Log in to GitHub Container Registry using GITHUB_TOKEN
    - name: Log in to GitHub Container Registry
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build Docker image for ${{ matrix.domain }}-${{ matrix.app }}
      env:
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
      run: |
        # Use full domain-app format to avoid ambiguity
        FULL_APP_NAME="${DOMAIN}-${APP}"
        echo "Building Docker image for $FULL_APP_NAME using release tool..."
        bazel run //tools:release -- build "$FULL_APP_NAME"
        
        # Show the built Docker image
        echo "Built Docker image for $FULL_APP_NAME:"
        docker images | grep -E "(REPOSITORY|$FULL_APP_NAME)" || docker images | head -5
        
    - name: Push image to registry (main branch only)
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      env:
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
      run: |
        # Use full domain-app format to avoid ambiguity
        FULL_APP_NAME="${DOMAIN}-${APP}"
        echo "Publishing $FULL_APP_NAME image to registry..."
        # Only push 'latest' tag on main branch - version-specific and commit tags are reserved for releases
        bazel run //tools:release -- release-multiarch "$FULL_APP_NAME" --version "latest"
        # Shutdown Bazel server to prevent hanging
        bazel shutdown
        
  # Build summary - collects status of all matrix jobs for branch protection
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [build, test, plan-docker, test-container-arch, docker]
    if: always()
    steps:
    - name: Collect build results and generate summary
      run: |
        echo "=== CI Build Summary ===" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check the status of all jobs
        BUILD_RESULT="${{ needs.build.result }}"
        TEST_RESULT="${{ needs.test.result }}"
        CONTAINER_ARCH_RESULT="${{ needs.test-container-arch.result }}"
        PLAN_JOB_RESULT="${{ needs.plan-docker.result }}"
        DOCKER_RESULT="${{ needs.docker.result }}"
        
        echo "**Job Results:**" >> $GITHUB_STEP_SUMMARY
        echo "- Build: $BUILD_RESULT" >> $GITHUB_STEP_SUMMARY
        echo "- Test: $TEST_RESULT" >> $GITHUB_STEP_SUMMARY
        echo "- Container Architecture Test: $CONTAINER_ARCH_RESULT" >> $GITHUB_STEP_SUMMARY
        echo "- Planning: $PLAN_JOB_RESULT" >> $GITHUB_STEP_SUMMARY
        echo "- Docker: $DOCKER_RESULT" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check if any apps were planned for building
        PLANNED_APPS="${{ needs.plan-docker.outputs.apps }}"
        if [[ -n "$PLANNED_APPS" && "$PLANNED_APPS" != "null" ]]; then
          echo "**Apps processed:** $PLANNED_APPS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Determine overall status
        # Build job must always pass
        if [[ "$BUILD_RESULT" != "success" ]]; then
          echo "❌ **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Build job failed - compilation is broken!" >> $GITHUB_STEP_SUMMARY
          echo "::error::Build job failed"
          exit 1
        fi
        
        # Test job must always pass
        if [[ "$TEST_RESULT" != "success" ]]; then
          echo "❌ **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Test job failed - tests are failing!" >> $GITHUB_STEP_SUMMARY
          echo "::error::Test job failed"
          exit 1
        fi
        
        # Container arch test must always pass
        if [[ "$CONTAINER_ARCH_RESULT" != "success" ]]; then
          echo "❌ **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Container architecture test failed - cross-compilation is broken!" >> $GITHUB_STEP_SUMMARY
          echo "::error::Container architecture test failed"
          exit 1
        fi
        
        # For PRs, docker job is skipped (only runs on main)
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          echo "✅ **Overall Status: PASSED**" >> $GITHUB_STEP_SUMMARY
          echo "All required checks passed for PR (Docker builds only run on main branch)" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        # For main branch, check docker builds if apps were planned
        if [[ -z "$PLANNED_APPS" || "$PLANNED_APPS" == "null" ]]; then
          echo "✅ **Overall Status: PASSED** (no builds needed)" >> $GITHUB_STEP_SUMMARY
          echo "No apps needed building - all changes were in non-app areas" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        # If we have apps to build on main, check docker job status
        # Docker job runs when: github.event_name == 'push' && github.ref == 'refs/heads/main' && apps exist
        if [[ "$DOCKER_RESULT" == "success" ]]; then
          echo "✅ **Overall Status: PASSED**" >> $GITHUB_STEP_SUMMARY
          echo "All jobs including Docker builds completed successfully!" >> $GITHUB_STEP_SUMMARY
          exit 0
        elif [[ "$DOCKER_RESULT" == "skipped" ]]; then
          # Docker was skipped - this is expected behavior when conditions aren't met
          echo "✅ **Overall Status: PASSED**" >> $GITHUB_STEP_SUMMARY
          echo "All required jobs passed (Docker builds were skipped)" >> $GITHUB_STEP_SUMMARY
          exit 0
        else
          # Docker job failed or was cancelled
          echo "❌ **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Docker builds failed for one or more apps!" >> $GITHUB_STEP_SUMMARY
          echo "::error::Docker job failed with status: $DOCKER_RESULT"
          exit 1
        fi
        
