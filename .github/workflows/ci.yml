name: CI

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

env:
  # Shared cache key components for consistent caching across jobs
  CACHE_KEY_FILES: '**/BUILD.bazel,**/*.bzl,MODULE.bazel,MODULE.bazel.lock,go.mod,requirements.lock.txt,.bazelrc,.bazelversion'

jobs:
  # Build job - builds applications first
  build:
    name: Build
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Bazelisk
      uses: bazelbuild/setup-bazelisk@v3
      
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25'  # Match MODULE.bazel version
        
    - name: Setup Go module cache
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ hashFiles('go.mod', 'go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
        
    - name: Mount Bazel cache
      uses: actions/cache@v4
      with:
        path: |
          /tmp/bazel-cache
          /tmp/bazel-repo-cache
          ~/.cache/bazelisk
        key: ${{ runner.os }}-bazel-${{ hashFiles(env.CACHE_KEY_FILES) }}
        restore-keys: |
          ${{ runner.os }}-bazel-
          
    - name: Configure Bazel and Go caches
      run: |
        # Create Bazel cache directories
        mkdir -p /tmp/bazel-cache /tmp/bazel-repo-cache
        # Initialize Go cache directories using Bazel tool
        bazel run //:init-go-cache
        
    - name: Build applications
      run: |
        # Build all binary targets (not libraries or tests) with CI optimizations
        bazel query "kind('.*_binary', //...)" | xargs bazel build --config=ci
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          bazel-bin/*/
          !bazel-bin/**/runfiles/
          !bazel-bin/**/*.runfiles/
          !bazel-bin/**/*_test*
          !bazel-bin/**/*.so
        retention-days: 3

  # Test job - runs tests after successful build
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Bazelisk
      uses: bazelbuild/setup-bazelisk@v3
      
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25'  # Match MODULE.bazel version
        
    - name: Setup Go module cache
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ hashFiles('go.mod', 'go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
        
    - name: Mount Bazel cache
      uses: actions/cache@v4
      with:
        path: |
          /tmp/bazel-cache
          /tmp/bazel-repo-cache
          ~/.cache/bazelisk
        key: ${{ runner.os }}-bazel-${{ hashFiles(env.CACHE_KEY_FILES) }}
        restore-keys: |
          ${{ runner.os }}-bazel-
          
    - name: Configure Bazel and Go caches
      run: |
        # Create Bazel cache directories
        mkdir -p /tmp/bazel-cache /tmp/bazel-repo-cache
        # Initialize Go cache directories using Bazel tool
        bazel run //:init-go-cache
        
    - name: Run tests
      run: |
        # Bazel automatically handles incremental testing
        # Only rebuilds and retests what's affected by changes
        bazel test --config=ci //...
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: bazel-testlogs/
        retention-days: 7

  # Docker job - builds container images using Bazel OCI rules
  docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test  # Changed from build to test since we build everything in this job
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Bazelisk
      uses: bazelbuild/setup-bazelisk@v3
      
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25'  # Match MODULE.bazel version
        
    - name: Setup Go module cache
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ hashFiles('go.mod', 'go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
        
    - name: Mount Bazel cache
      uses: actions/cache@v4
      with:
        path: |
          /tmp/bazel-cache
          /tmp/bazel-repo-cache
          ~/.cache/bazelisk
        key: ${{ runner.os }}-bazel-${{ hashFiles(env.CACHE_KEY_FILES) }}
        restore-keys: |
          ${{ runner.os }}-bazel-
          
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Configure Bazel and Go caches
      run: |
        # Create Bazel cache directories
        mkdir -p /tmp/bazel-cache /tmp/bazel-repo-cache
        # Initialize Go cache directories using Bazel tool
        bazel run //:init-go-cache
      
    # NOTE: GHCR_PAT secret should be created with write:packages and read:packages scopes
    # Falls back to GITHUB_TOKEN if GHCR_PAT is not available (limited permissions)
    - name: Log in to GitHub Container Registry
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
        
    - name: Build and load Docker images with Bazel
      run: |
        # First, build all OCI images using Bazel with CI optimizations
        echo "Building OCI images..."
        bazel build --config=ci $(bazel query "kind('oci_load', //...)")
        
        # Show what tarball scripts were generated
        echo "Generated OCI tarball scripts:"
        ls -la bazel-bin/*/*tarball.sh || echo "No tarball scripts found"
        
        # Then load images into Docker daemon using the generated scripts
        echo "Loading images into Docker daemon..."
        for script in bazel-bin/*/*tarball.sh; do
          if [[ -x "$script" ]]; then
            echo "Loading image from $script"
            "$script"
          else
            echo "Warning: Script not executable or not found: $script"
          fi
        done
        
        # Show loaded Docker images
        echo "Loaded Docker images:"
        docker images
        
        # Tag and push images if on main branch
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
          # Get all loaded images and tag/push them to GHCR
          for image in $(docker images --format "table {{.Repository}}:{{.Tag}}" | grep -v REPOSITORY | grep -v "<none>"); do
            if [[ "$image" != *"/"* ]]; then  # Skip images that already have a registry prefix
              # Convert to lowercase for GHCR compatibility
              app_name=$(echo "${image%:*}" | tr '[:upper:]' '[:lower:]')
              ghcr_image="ghcr.io/${{ github.repository_owner }}/$app_name:latest"
              ghcr_commit_image="ghcr.io/${{ github.repository_owner }}/$app_name:${{ github.sha }}"
              
              echo "Tagging and pushing $image as $ghcr_image and $ghcr_commit_image"
              docker tag "$image" "$ghcr_image"
              docker tag "$image" "$ghcr_commit_image"
              docker push "$ghcr_image"
              docker push "$ghcr_commit_image"
            fi
          done
        fi
        
    - name: Save Docker images as artifacts
      if: github.event_name == 'pull_request'
      run: |
        # Save images for PR builds
        mkdir -p docker-images
        for image in $(docker images --format "table {{.Repository}}:{{.Tag}}" | grep -v REPOSITORY | grep -v "<none>"); do
          if [[ "$image" != *"/"* ]]; then  # Skip images that already have a registry prefix
            safe_name=$(echo "$image" | tr ':/' '_')
            echo "Saving image $image as docker-images/${safe_name}.tar.gz"
            docker save "$image" | gzip > "docker-images/${safe_name}.tar.gz"
          fi
        done
        
    - name: Upload Docker images
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: docker-images
        path: docker-images/
        retention-days: 3
