name: Release

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'Comma-separated list of apps to release (e.g., hello_python,hello_go) or "all" for all apps, or domain name (e.g., "demo") to release all apps in a domain. Leave empty to skip app release.'
        required: false
        default: ''
      version:
        description: 'Release version (e.g., v1.0.0) - leave empty when using increment options'
        required: false
      increment_minor:
        description: 'Auto-increment minor version (resets patch to 0) - applies to both apps and helm charts'
        type: boolean
        default: false
      increment_patch:
        description: 'Auto-increment patch version - applies to both apps and helm charts'
        type: boolean
        default: false
      dry_run:
        description: 'Dry run - build but do not publish'
        type: boolean
        default: false
      helm_charts:
        description: 'Helm charts to release (e.g., hello-fastapi,demo-workers) or "all" or domain name (e.g., "demo"). Leave empty to skip helm chart release.'
        required: false
        default: ''
      include_demo:
        description: 'Include demo domain when using "all" for apps or helm charts'
        type: boolean
        default: false

# Global concurrency control for all release operations
# Prevents race conditions across app releases, git tags, GitHub releases, and Helm repository
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # Validate inputs and ensure mutual exclusivity
  validate-inputs:
    name: Validate Inputs
    runs-on: ubuntu-latest
    steps:
    - name: Validate release targets
      run: |
        APPS="${{ github.event.inputs.apps }}"
        HELM_CHARTS="${{ github.event.inputs.helm_charts }}"
        
        # Ensure at least one of apps or helm_charts is specified
        if [[ -z "$APPS" && -z "$HELM_CHARTS" ]]; then
          echo "Error: Must specify at least one of 'apps' or 'helm_charts'"
          exit 1
        fi
        
        echo "✅ Release targets validated: apps='$APPS', helm_charts='$HELM_CHARTS'"
    
    - name: Validate mutually exclusive version options
      run: |
        VERSION="${{ github.event.inputs.version }}"
        INCREMENT_MINOR="${{ github.event.inputs.increment_minor }}"
        INCREMENT_PATCH="${{ github.event.inputs.increment_patch }}"
        
        # Count how many version options are set
        OPTION_COUNT=0
        if [[ -n "$VERSION" ]]; then
          OPTION_COUNT=$((OPTION_COUNT + 1))
        fi
        if [[ "$INCREMENT_MINOR" == "true" ]]; then
          OPTION_COUNT=$((OPTION_COUNT + 1))
        fi
        if [[ "$INCREMENT_PATCH" == "true" ]]; then
          OPTION_COUNT=$((OPTION_COUNT + 1))
        fi
        
        # Ensure exactly one option is set
        if [[ $OPTION_COUNT -eq 0 ]]; then
          echo "Error: Must specify exactly one of: version, increment_minor, or increment_patch"
          exit 1
        elif [[ $OPTION_COUNT -gt 1 ]]; then
          echo "Error: version, increment_minor, and increment_patch are mutually exclusive. Specify only one."
          exit 1
        fi
        
        echo "✅ Version input validation passed"

  # Detect what apps have changed and build release plan
  plan-release:
    name: Plan Release
    runs-on: ubuntu-latest
    needs: validate-inputs
    outputs:
      release-matrix: ${{ steps.plan.outputs.matrix }}
      version: ${{ steps.plan.outputs.version }}
      apps: ${{ steps.plan.outputs.apps }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Plan release using release helper tool
      id: plan
      run: |
        # Determine version mode and build command
        VERSION="${{ github.event.inputs.version }}"
        INCREMENT_MINOR="${{ github.event.inputs.increment_minor }}"
        INCREMENT_PATCH="${{ github.event.inputs.increment_patch }}"
        EVENT_TYPE="workflow_dispatch"
        APPS_INPUT="${{ github.event.inputs.apps }}"
        INCLUDE_DEMO="${{ github.event.inputs.include_demo }}"
        
        # Only plan app release if apps are specified
        if [[ -n "$APPS_INPUT" ]]; then
          # Build the command based on the selected option
          CMD="bazel run --config=ci //tools:release -- plan --event-type \"$EVENT_TYPE\" --apps \"$APPS_INPUT\" --format github"
          
          # Add --include-demo flag if checkbox is selected
          if [[ "$INCLUDE_DEMO" == "true" ]]; then
            CMD="$CMD --include-demo"
          fi
          
          if [[ -n "$VERSION" ]]; then
            CMD="$CMD --version \"$VERSION\""
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          elif [[ "$INCREMENT_MINOR" == "true" ]]; then
            CMD="$CMD --increment-minor"
            echo "Planning minor version increment"
          elif [[ "$INCREMENT_PATCH" == "true" ]]; then
            CMD="$CMD --increment-patch"
            echo "Planning patch version increment"
          fi
          
          # Use release helper to plan the release
          echo "Planning release with command: $CMD"
          PLAN_OUTPUT=$(eval $CMD)
          
          # Parse output from release helper
          echo "$PLAN_OUTPUT" | while IFS= read -r line; do
            if [[ "$line" == matrix=* ]]; then
              echo "${line}" >> $GITHUB_OUTPUT
            elif [[ "$line" == apps=* ]]; then
              echo "${line}" >> $GITHUB_OUTPUT
              APPS_LIST="${line#apps=}"
              if [[ -n "$APPS_LIST" ]]; then
                echo "Release plan: $APPS_LIST"
              else
                echo "No apps to release"
              fi
            fi
          done
        else
          echo "No apps specified, skipping app release planning"
          # Still need to output version for helm charts
          if [[ -n "$VERSION" ]]; then
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          fi
        fi

  # Plan which apps need OpenAPI spec builds
  plan-openapi-builds:
    name: Plan OpenAPI Builds
    runs-on: ubuntu-latest
    needs: plan-release
    if: needs.plan-release.outputs.apps != ''
    outputs:
      openapi-matrix: ${{ steps.plan-openapi.outputs.matrix }}
      has-specs: ${{ steps.plan-openapi.outputs.has-specs }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Plan OpenAPI spec builds
      id: plan-openapi
      env:
        APPS: ${{ needs.plan-release.outputs.apps }}
      run: |
        echo "Planning OpenAPI spec builds for apps: $APPS"
        
        # Use release helper to identify apps with OpenAPI specs
        PLAN_OUTPUT=$(bazel run --config=ci //tools:release -- plan-openapi-builds --apps "$APPS" --format github)
        
        # Parse output
        echo "$PLAN_OUTPUT" | while IFS= read -r line; do
          if [[ "$line" == matrix=* ]]; then
            echo "${line}" >> $GITHUB_OUTPUT
            MATRIX_VALUE="${line#matrix=}"
            # Check if matrix is empty
            if [[ "$MATRIX_VALUE" == "{}" ]]; then
              echo "has-specs=false" >> $GITHUB_OUTPUT
            else
              echo "has-specs=true" >> $GITHUB_OUTPUT
            fi
          fi
        done
        
        # If no matrix was set, mark as no specs
        if ! grep -q "matrix=" <<< "$PLAN_OUTPUT"; then
          echo "matrix={}" >> $GITHUB_OUTPUT
          echo "has-specs=false" >> $GITHUB_OUTPUT
        fi

  # Build OpenAPI specs for FastAPI apps (only apps that have specs)
  build-openapi-specs:
    name: Build OpenAPI Spec for ${{ matrix.domain }}-${{ matrix.app }}
    runs-on: ubuntu-latest
    needs: [plan-release, plan-openapi-builds]
    if: needs.plan-openapi-builds.outputs.has-specs == 'true' && github.event.inputs.dry_run == 'false'
    strategy:
      matrix: ${{ fromJson(needs.plan-openapi-builds.outputs.openapi-matrix) }}
      fail-fast: false
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
    
    - name: Build OpenAPI spec
      continue-on-error: true
      env:
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
        OPENAPI_TARGET: ${{ matrix.openapi_target }}
      run: |
        echo "Building OpenAPI spec for $APP..."
        echo "Target: $OPENAPI_TARGET"
        
        # Build the OpenAPI spec
        if bazel build --config=ci "$OPENAPI_TARGET"; then
          # Find the generated spec file - it's now named {domain}-{app}_openapi_spec.json
          # Remove @@// or // prefix from target (Bazel 8.x uses @@ prefix for main repo)
          TARGET_PATH="${OPENAPI_TARGET#@@//}"
          TARGET_PATH="${TARGET_PATH#//}"
          
          # The target name includes _openapi_spec suffix, and now the file includes domain prefix
          # Format: bazel-bin/{path}/{domain}-{app}_openapi_spec.json
          BAZEL_BIN=$(bazel info bazel-bin --config=ci)
          TARGET_DIR=$(echo "$TARGET_PATH" | sed 's#:#/#' | sed 's#/[^/]*$##')
          
          # Try the new naming format with domain prefix first
          SPEC_FILE="${BAZEL_BIN}/${TARGET_DIR}/${DOMAIN}-${APP}_openapi_spec.json"
          
          # Fallback to old format if the new format doesn't exist (for backward compatibility)
          if [[ ! -f "$SPEC_FILE" ]]; then
            SPEC_FILE="${BAZEL_BIN}/${TARGET_PATH}.json"
            SPEC_FILE=$(echo "$SPEC_FILE" | sed 's#:#/#')
          fi
          
          if [[ -f "$SPEC_FILE" ]]; then
            # Create output directory
            mkdir -p /tmp/openapi-specs
            
            # Copy spec with a descriptive name
            cp "$SPEC_FILE" "/tmp/openapi-specs/${DOMAIN}-${APP}-openapi.json"
            
            echo "✅ OpenAPI spec saved to: /tmp/openapi-specs/${DOMAIN}-${APP}-openapi.json"
          else
            echo "⚠️ OpenAPI spec file not found at expected location: $SPEC_FILE"
            exit 1
          fi
        else
          echo "❌ Failed to build OpenAPI spec for $APP"
          exit 1
        fi
    
    - name: Upload OpenAPI spec artifact
      uses: actions/upload-artifact@v4
      with:
        name: openapi-spec-${{ matrix.domain }}-${{ matrix.app }}
        path: /tmp/openapi-specs/${{ matrix.domain }}-${{ matrix.app }}-openapi.json
        if-no-files-found: warn

  # Build and release selected apps
  release:
    name: Release ${{ matrix.domain }}-${{ matrix.app }}
    runs-on: ubuntu-latest
    needs: plan-release
    if: needs.plan-release.outputs.release-matrix != '' && fromJson(needs.plan-release.outputs.release-matrix).include[0] != null
    strategy:
      matrix: ${{ fromJson(needs.plan-release.outputs.release-matrix) }}
      fail-fast: false
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        setup-docker: 'true'
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    # Configure Git for tagging
    - name: Configure Git
      run: |
        git config --global user.name "${{ github.actor }}"
        git config --global user.email "${{ github.actor }}@users.noreply.github.com"
        
    # Login unless it's a manual dispatch with dry_run=true
    # - Manual dispatch with dry_run=false: login (needed for publishing)
    # - Manual dispatch with dry_run=true: skip login (no publishing)
    # NOTE: GHCR_PAT secret should be created with write:packages and read:packages scopes
    # Falls back to GITHUB_TOKEN if GHCR_PAT is not available (limited permissions)
    - name: Log in to GitHub Container Registry
      if: ${{ github.event.inputs.dry_run == 'false' }}
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
        
    - name: Build and release app using multiarch release
      env:
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
        VERSION: ${{ matrix.version || needs.plan-release.outputs.version }}
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      run: |
        # Use full domain-app format to avoid ambiguity
        FULL_APP_NAME="${DOMAIN}-${APP}"
        echo "Building and releasing $FULL_APP_NAME version $VERSION using multiarch release system"
        
        # Build the release helper binary first (avoids nested Bazel invocations)
        echo "Building release helper..."
        bazel build --config=ci //tools:release
        
        # Execute the release helper directly (not via 'bazel run' to avoid deadlocks)
        RELEASE_HELPER="$(bazel info bazel-bin --config=ci)/tools/release_helper/release_helper"
        
        # Use release-multiarch with full domain-app name to ensure correct artifact is released
        if [[ "$DRY_RUN" == "true" ]]; then
          echo "DRY RUN: Building multiarch images without publishing"
          "$RELEASE_HELPER" release-multiarch "$FULL_APP_NAME" --version "$VERSION" --commit "${{ github.sha }}" --dry-run
        else
          echo "Building and publishing multiarch images for $FULL_APP_NAME $VERSION"
          "$RELEASE_HELPER" release-multiarch "$FULL_APP_NAME" --version "$VERSION" --commit "${{ github.sha }}"
          echo "Successfully released multiarch $FULL_APP_NAME $VERSION"
        fi
        
    - name: Create git tag for release
      if: ${{ github.event.inputs.dry_run == 'false' }}
      env:
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
        VERSION: ${{ matrix.version || needs.plan-release.outputs.version }}
      run: |
        # Use domain from matrix (avoids ambiguity when apps share names across domains)
        TAG_NAME="${DOMAIN}-${APP}.${VERSION}"
        
        # Check if tag already exists
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "ℹ️  Tag $TAG_NAME already exists, skipping creation"
        else
          echo "Creating git tag: $TAG_NAME"
          git tag -a "$TAG_NAME" -m "Release ${DOMAIN}-${APP} version $VERSION" "${{ github.sha }}"
          git push origin "$TAG_NAME"
          echo "✅ Created and pushed git tag: $TAG_NAME"
        fi

    - name: Generate release notes for app
      if: ${{ github.event.inputs.dry_run == 'false' }}
      id: release-notes
      env:
        APP: ${{ matrix.app }}
        DOMAIN: ${{ matrix.domain }}
        VERSION: ${{ matrix.version || needs.plan-release.outputs.version }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      run: |
        # Use full domain-app format to avoid ambiguity
        FULL_APP_NAME="${DOMAIN}-${APP}"
        echo "Generating release notes for $FULL_APP_NAME version $VERSION"
        
        # Tag format uses domain-appname.version
        TAG_NAME="${DOMAIN}-${APP}.${VERSION}"
        
        # Output domain for use in upload step
        echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
        
        echo "## 📝 Release Notes for $TAG_NAME" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Generate release notes using the release helper with full app name
        RELEASE_NOTES=$(bazel run --config=ci //tools:release -- release-notes "$FULL_APP_NAME" \
          --current-tag "$TAG_NAME" \
          --format markdown 2>/dev/null || echo "Release notes generation skipped - no previous tags found")
        
        echo "Release notes generated for $FULL_APP_NAME:"
        echo "$RELEASE_NOTES"
        
        # Add to GitHub step summary
        echo "$RELEASE_NOTES" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "✅ Release notes generated for $FULL_APP_NAME $VERSION"
        
        # Save release notes to a file for the GitHub release creation job
        mkdir -p /tmp/release-notes
        echo "$RELEASE_NOTES" > "/tmp/release-notes/${DOMAIN}-${APP}.md"
    
    - name: Upload release notes artifact
      if: ${{ github.event.inputs.dry_run == 'false' }}
      uses: actions/upload-artifact@v4
      with:
        name: release-notes-${{ matrix.domain }}-${{ matrix.app }}
        path: /tmp/release-notes/${{ steps.release-notes.outputs.domain }}-${{ matrix.app }}.md
        if-no-files-found: ignore

  create-github-releases:
    name: Create GitHub Releases
    runs-on: ubuntu-latest
    needs: [plan-release, release, build-openapi-specs]
    if: always() && !cancelled() && needs.plan-release.outputs.release-matrix != '' && fromJson(needs.plan-release.outputs.release-matrix).include[0] != null && github.event.inputs.dry_run == 'false' && needs.release.result == 'success' && (needs.build-openapi-specs.result == 'success' || needs.build-openapi-specs.result == 'skipped')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
    
    - name: Download release notes artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: release-notes-*
        path: /tmp/release-notes
        merge-multiple: true
    
    - name: Download OpenAPI spec artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: openapi-spec-*
        path: /tmp/openapi-specs
        merge-multiple: true
      continue-on-error: true
      
    - name: Create GitHub releases for all apps
      env:
        MATRIX: ${{ needs.plan-release.outputs.release-matrix }}
        VERSION: ${{ needs.plan-release.outputs.version }}
        GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Creating GitHub releases for all apps in version $VERSION..."
        
        # Extract app names from matrix in full domain-app format to avoid ambiguity
        APPS=$(echo "$MATRIX" | jq -r '.include[] | "\(.domain)-\(.app)"' | tr '\n' ',' | sed 's/,$//')
        
        if [[ -n "$APPS" && "$APPS" != "" ]]; then
          echo "Creating releases for apps: $APPS"
          
          # List available release notes files
          echo "Available release notes files:"
          ls -la /tmp/release-notes/ || echo "No release notes files found"
          
          # List available OpenAPI spec files
          echo "Available OpenAPI spec files:"
          ls -la /tmp/openapi-specs/ || echo "No OpenAPI spec files found"
          
          # Create releases for all apps at once, using pre-generated release notes
          if bazel run --config=ci //tools:release -- create-combined-github-release-with-notes "$VERSION" \
            --owner "$GITHUB_REPOSITORY_OWNER" \
            --repo "$GITHUB_REPOSITORY_NAME" \
            --commit "${{ github.sha }}" \
            --apps "$APPS" \
            --release-notes-dir "/tmp/release-notes" \
            --openapi-specs-dir "/tmp/openapi-specs"; then
            echo "✅ Successfully created GitHub releases for version $VERSION"
          else
            echo "❌ Failed to create GitHub releases for version $VERSION"
            exit 1  # Fail the job if release creation fails
          fi
        else
          echo "No apps found in matrix, skipping release creation"
        fi

  release-summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [plan-release, release, create-github-releases, release-helm-charts]
    if: always()
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'docker'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
      
    - name: Generate summary using release helper
      run: |
        # Use our release helper tool to generate the summary
        MATRIX='${{ needs.plan-release.outputs.release-matrix }}'
        EVENT_TYPE="workflow_dispatch"
        DRY_RUN="${{ github.event.inputs.dry_run == 'true' && '--dry-run' || '' }}"
        
        SUMMARY=$(bazel run //tools:release -- summary \
          --matrix "$MATRIX" \
          --version "${{ needs.plan-release.outputs.version }}" \
          --event-type "$EVENT_TYPE" \
          --repository-owner "${{ github.repository_owner }}" \
          $DRY_RUN)
        
        echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY
        
    - name: Add helm chart summary
      if: github.event.inputs.helm_charts != ''
      run: |
        HELM_CHARTS="${{ github.event.inputs.helm_charts }}"
        VERSION="${{ needs.plan-release.outputs.version }}"
        DRY_RUN="${{ github.event.inputs.dry_run }}"
        HELM_JOB_RESULT="${{ needs.release-helm-charts.result }}"
        REPO_OWNER="${{ github.repository_owner }}"
        REPO_NAME="${{ github.event.repository.name }}"
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 🎯 Helm Chart Release" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "$HELM_JOB_RESULT" == "success" ]]; then
          echo "**Status:** ✅ Success" >> $GITHUB_STEP_SUMMARY
          echo "**Charts:** $HELM_CHARTS" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$DRY_RUN" != "true" ]]; then
            echo "### 📚 Helm Repository" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Charts have been published to the Helm repository:" >> $GITHUB_STEP_SUMMARY
            echo "- **Repository URL:** https://charts.whalenet.dev/" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "### 🏷️ Git Tags" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Git tags have been created for version tracking:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List the created tags based on chart names
            IFS=',' read -ra CHART_ARRAY <<< "$HELM_CHARTS"
            for CHART in "${CHART_ARRAY[@]}"; do
              CHART=$(echo "$CHART" | xargs) # trim whitespace
              if [[ "$CHART" != "all" ]]; then
                # Tags keep the helm- prefix to avoid collisions with app tags
                echo "- \`${CHART}.v${VERSION}\`" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "**Add the repository:**" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "helm repo add whalenet https://charts.whalenet.dev/" >> $GITHUB_STEP_SUMMARY
            echo "helm repo update" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Install a chart:**" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "helm search repo whalenet" >> $GITHUB_STEP_SUMMARY
            echo "helm install my-release whalenet/<chart-name>" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "📥 **Chart packages available as workflow artifacts**" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ℹ️ *Dry run mode - charts built but not published*" >> $GITHUB_STEP_SUMMARY
          fi
        elif [[ "$HELM_JOB_RESULT" == "skipped" ]]; then
          echo "**Status:** ⏭️ Skipped (no charts specified)" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Status:** ❌ Failed or Cancelled" >> $GITHUB_STEP_SUMMARY
        fi

  # Release helm charts (must run after app images are built and tagged)
  release-helm-charts:
    name: Release Helm Charts
    needs: [plan-release, release, create-github-releases]
    if: github.event.inputs.helm_charts != '' && (always() && !cancelled())
    runs-on: ubuntu-latest
    permissions:
      contents: write     # Push git tags and read repository content
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
        
    - name: Setup Build Environment
      uses: ./.github/actions/setup-build-env
      with:
        cache-suffix: 'helm'
        bazel-remote-cache-url: ${{ secrets.BAZEL_REMOTE_CACHE_URL }}
        bazel-remote-cache-user: ${{ secrets.BAZEL_REMOTE_CACHE_USER }}
        bazel-remote-cache-password: ${{ secrets.BAZEL_REMOTE_CACHE_PASSWORD }}
        
    - name: Install Helm
      uses: azure/setup-helm@v4
      with:
        version: 'latest'
        
    - name: Plan helm chart release
      id: plan
      run: |
        CHARTS_INPUT="${{ github.event.inputs.helm_charts }}"
        VERSION="${{ needs.plan-release.outputs.version }}"
        INCLUDE_DEMO="${{ github.event.inputs.include_demo }}"
        
        echo "Planning helm chart release for: $CHARTS_INPUT"
        echo "Using version: $VERSION"
        
        # Build the command with optional --include-demo flag
        CMD="bazel run --config=ci //tools:release -- plan-helm-release --charts \"$CHARTS_INPUT\" --version \"$VERSION\" --format github"
        
        if [[ "$INCLUDE_DEMO" == "true" ]]; then
          CMD="$CMD --include-demo"
        fi
        
        echo "Planning with command: $CMD"
        
        # Use release helper to plan the helm chart release
        PLAN_OUTPUT=$(eval $CMD)
        
        # Parse output from release helper
        echo "$PLAN_OUTPUT" | while IFS= read -r line; do
          if [[ "$line" == matrix=* ]]; then
            echo "${line}" >> $GITHUB_OUTPUT
          elif [[ "$line" == charts=* ]]; then
            echo "${line}" >> $GITHUB_OUTPUT
            CHARTS_LIST="${line#charts=}"
            if [[ -n "$CHARTS_LIST" ]]; then
              echo "Release plan: $CHARTS_LIST"
            else
              echo "No charts to release"
            fi
          fi
        done
        
    - name: Build helm charts with versioning
      if: steps.plan.outputs.charts != ''
      env:
        VERSION: ${{ needs.plan-release.outputs.version }}
        DRY_RUN: ${{ github.event.inputs.dry_run }}
        INCREMENT_MINOR: ${{ github.event.inputs.increment_minor }}
        INCREMENT_PATCH: ${{ github.event.inputs.increment_patch }}
      run: |
        echo "Building helm charts with version $VERSION"
        
        # Determine bump type based on increment inputs
        BUMP_TYPE="patch"  # Default to patch
        if [[ "$INCREMENT_MINOR" == "true" ]]; then
          BUMP_TYPE="minor"
          echo "Using minor version bump for helm charts"
        elif [[ "$INCREMENT_PATCH" == "true" ]]; then
          BUMP_TYPE="patch"
          echo "Using patch version bump for helm charts"
        fi
        
        # Create output directory for charts
        mkdir -p /tmp/helm-charts
        
        # Build the release helper binary first (avoids nested Bazel invocations)
        echo "Building release helper..."
        bazel build --config=ci //tools:release
        RELEASE_HELPER="$(bazel info bazel-bin --config=ci)/tools/release_helper/release_helper"
        
        # Parse chart list and build each chart with proper versioning
        CHARTS="${{ steps.plan.outputs.charts }}"
        IFS=' ' read -ra CHART_ARRAY <<< "$CHARTS"
        
        for CHART in "${CHART_ARRAY[@]}"; do
          echo "Building chart: $CHART with auto-versioning (bump: $BUMP_TYPE)"
          
          # Build the chart using release helper with auto-versioning
          # Each chart maintains its own version based on git tags (helm/<chart-name>/v*)
          # Note: --auto-version is the default, so we don't need to pass it explicitly
          "$RELEASE_HELPER" build-helm-chart "$CHART" \
            --output-dir /tmp/helm-charts \
            --use-released \
            --bump "$BUMP_TYPE"
          
          echo "✅ Chart $CHART built successfully with auto-versioning (bump: $BUMP_TYPE)"
        done
        
        # List generated charts with versions
        echo "Generated versioned charts:"
        ls -lh /tmp/helm-charts/
        
    - name: Configure Git for tagging
      if: steps.plan.outputs.charts != '' && github.event.inputs.dry_run == 'false'
      run: |
        git config --global user.name "${{ github.actor }}"
        git config --global user.email "${{ github.actor }}@users.noreply.github.com"
        
    - name: Create and push helm chart tags
      if: steps.plan.outputs.charts != '' && github.event.inputs.dry_run == 'false'
      env:
        VERSION: ${{ needs.plan-release.outputs.version }}
        CHARTS: ${{ steps.plan.outputs.charts }}
      run: |
        echo "Creating git tags for helm chart releases..."
        
        # Parse chart list and create tags for each chart
        IFS=' ' read -ra CHART_ARRAY <<< "$CHARTS"
        
        for CHART in "${CHART_ARRAY[@]}"; do
          # Strip helm- prefix from chart name for file lookup
          # Chart names internally use helm-namespace-name format,
          # but published files use namespace-name format (without helm- prefix)
          PUBLISHED_NAME="${CHART#helm-}"
          
          # Extract the actual version from the packaged chart filename
          CHART_FILE=$(ls /tmp/helm-charts/${PUBLISHED_NAME}-*.tgz 2>/dev/null | head -n1)
          
          if [[ -f "$CHART_FILE" ]]; then
            # Extract version from filename (e.g., demo-hello-fastapi-v0.2.1.tgz -> v0.2.1)
            CHART_VERSION=$(basename "$CHART_FILE" | sed -E "s/${PUBLISHED_NAME}-(.+)\.tgz/\1/")
            
            # Format: {chart-name}.{version} (keep helm- prefix in tags to avoid collisions)
            TAG_NAME="${CHART}.${CHART_VERSION}"
            
            echo "Creating tag: $TAG_NAME for chart $CHART (published as $PUBLISHED_NAME)"
            
            # Check if tag already exists
            if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
              echo "ℹ️  Tag $TAG_NAME already exists, skipping creation"
            else
              # Create annotated tag
              git tag -a "$TAG_NAME" -m "Release helm chart $CHART version ${CHART_VERSION}" "${{ github.sha }}"
              
              # Push the tag
              git push origin "$TAG_NAME"
              
              echo "✅ Created and pushed tag: $TAG_NAME"
            fi
          else
            echo "⚠️ Warning: Could not find chart file for $CHART (looking for ${PUBLISHED_NAME}-*.tgz)"
          fi
        done
        
        echo "✅ All helm chart tags created and pushed"
        
    - name: Publish charts to ChartMuseum
      if: steps.plan.outputs.charts != '' && github.event.inputs.dry_run == 'false'
      env:
        CHART_REPO_USER: ${{ secrets.CHART_REPO_USER }}
        CHART_REPO_PASS: ${{ secrets.CHART_REPO_PASS }}
      run: |
        echo "Publishing charts to https://charts.whalenet.dev/..."
        
        REPO_URL="https://charts.whalenet.dev"
        
        # Verify chart files exist before attempting upload
        CHART_COUNT=$(ls -1 /tmp/helm-charts/*.tgz 2>/dev/null | wc -l)
        if [ "$CHART_COUNT" -eq 0 ]; then
          echo "❌ Error: No chart files found in /tmp/helm-charts/"
          exit 1
        fi
        
        echo "Found $CHART_COUNT chart(s) to publish"
        
        # Upload new chart packages using ChartMuseum API
        # ChartMuseum will automatically regenerate index.yaml
        # See: https://github.com/helm/chartmuseum#uploading-a-chart-package
        UPLOAD_FAILED=0
        for chart in /tmp/helm-charts/*.tgz; do
          if [ -f "$chart" ]; then
            chart_name=$(basename "$chart")
            echo "Uploading $chart_name via ChartMuseum API..."
            
            # POST to /api/charts endpoint with error handling
            # ChartMuseum will extract version from the chart package and update index
            if curl --fail-with-body -u "${CHART_REPO_USER}:${CHART_REPO_PASS}" \
                    --data-binary "@${chart}" \
                    "${REPO_URL}/api/charts" 2>&1; then
              echo "✅ Uploaded $chart_name"
            else
              echo "❌ Failed to upload $chart_name"
              UPLOAD_FAILED=1
            fi
          fi
        done
        
        if [ "$UPLOAD_FAILED" -eq 1 ]; then
          echo "❌ One or more chart uploads failed"
          exit 1
        fi
        
        echo "✅ All charts published successfully"
        
    - name: Report deployment URL
      if: steps.plan.outputs.charts != '' && github.event.inputs.dry_run == 'false'
      run: |
        echo "✅ Helm charts deployed to https://charts.whalenet.dev/!"
        echo ""
        echo "📦 Helm Repository URL:"
        echo "  https://charts.whalenet.dev/"
        echo ""
        echo "Users can add the repository with:"
        echo "  helm repo add whalenet https://charts.whalenet.dev/"
        echo "  helm repo update"
        
    - name: Upload helm chart artifacts
      if: steps.plan.outputs.charts != ''
      uses: actions/upload-artifact@v4
      with:
        name: helm-charts-auto-versioned
        path: /tmp/helm-charts/*.tgz
        if-no-files-found: error
